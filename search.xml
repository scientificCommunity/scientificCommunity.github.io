<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Auto DevOps之gitlab CI/CD</title>
    <url>/posts/7dfe0119/</url>
    <content><![CDATA[<h1 id="CI-CD介绍"><a href="#CI-CD介绍" class="headerlink" title="CI/CD介绍"></a>CI/CD介绍</h1><p><strong>CI(Continuous Integration)<strong>跟</strong>CD(Continuous Delivery/Continuous Deployment)<strong>的出现主要是为了帮助我们在开发时能更早的</strong>发现代码中的bug</strong>，避免我们<strong>在这些bug上进行后续的开发</strong>(一错再错-.-)，甚至将这些bug合并到qa或者staging环境去(错上加错)。</p>
<p>说人话就是，我们在提交代码到git时，git会<strong>自动</strong>通过脚本进行<strong>build跟test</strong>，如果这个过程失败了，我们会<strong>得到通知</strong>，这样我们就知道我们这次提交的代码是有问题的。同时这个检测过程<strong>不用任何人工干预</strong>(低成本)。</p>
<h1 id="CI-CD的工作流程"><a href="#CI-CD的工作流程" class="headerlink" title="CI/CD的工作流程"></a>CI/CD的工作流程</h1><ol>
<li>开启一个新的分支</li>
<li>运行自动化脚本来build或者test我们提交的代码</li>
<li>code review</li>
<li>运行自动化脚本来deploy我们提交的代码</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4ab2d185d65e76a0d58ad6564dff777a.png" alt="https://docs.gitlab.com/ee/ci/introduction/img/gitlab_workflow_example_11_9.png"></p>
<h1 id="ci整体原理"><a href="#ci整体原理" class="headerlink" title="ci整体原理"></a>ci整体原理</h1><ol>
<li><code>gitlab-runner</code>定时轮询(由<code>config.toml</code>的<code>check_interval</code>来指定间隔)<code>gitlab</code>指定的repo</li>
<li>提交代码到指定分支</li>
<li><code>gitlab-runner</code>检测到代码变动，执行项目中<code>.gitlab-ci.yml</code>中定义的脚本</li>
</ol>
<h1 id="安装gitlab-runner"><a href="#安装gitlab-runner" class="headerlink" title="安装gitlab runner"></a>安装gitlab runner</h1><h2 id="1-创建一个由docker管理的volumes"><a href="#1-创建一个由docker管理的volumes" class="headerlink" title="1. 创建一个由docker管理的volumes"></a>1. 创建一个由docker管理的volumes</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volumes create gitlab-runner</span><br></pre></td></tr></table></figure>

<ul>
<li>如果选择直接挂载一个文件目录，则忽略这一步</li>
<li>相对于直接挂载一个文件目录，该方式有更好的可移植性，其他更多优势<a href="https://docs.docker.com/storage/volumes/">请参考</a></li>
</ul>
<h2 id="2-创建并启动gitlab-runner容器"><a href="#2-创建并启动gitlab-runner容器" class="headerlink" title="2. 创建并启动gitlab-runner容器"></a>2. 创建并启动gitlab-runner容器</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">--name</span> <span class="string">gitlab-runner</span> <span class="string">--restart</span> <span class="string">always</span> <span class="string">\</span></span><br><span class="line">    <span class="string">-v</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span> <span class="string">\</span></span><br><span class="line">		<span class="string">-v</span> <span class="string">/bin/docker:/bin/docker</span> <span class="string">\</span></span><br><span class="line">    <span class="string">-v</span> <span class="string">gitlab-runner-config:/etc/gitlab-runner</span> <span class="string">\</span></span><br><span class="line">    <span class="string">gitlab/gitlab-runner:latest</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个挂载实现在容器内跟宿主机的<code>docker</code>通信（通过<code>curl</code>）</li>
<li>第二个挂载结合第一个挂载实现在容器内<code>docker.sock</code>执行宿主机<code>docker</code>命令</li>
</ul>
<h2 id="3-注册gitlab-runner"><a href="#3-注册gitlab-runner" class="headerlink" title="3. 注册gitlab-runner"></a>3. 注册gitlab-runner</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm -it -v gitlab-runner-config:/etc/gitlab-runner gitlab/gitlab-runner:latest register</span><br></pre></td></tr></table></figure>
<ol>
<li>填写<code>GitLab instance URL</code>。这个就是我们的<code>gitlab</code>实例的地址，如果是自建的，就填上自建实例的域名，如果用的官方的，则填上<code>https://gitlab.com</code></li>
<li>填写<code>token</code>。打开对应项目<code>--&gt;settings--&gt;ci/cd--&gt;runners</code>，即可看到<code>token</code></li>
<li>填写<code>description</code>. 这个根据这个<code>runner</code>的用途填写即可，没有特殊的</li>
<li>填写<code>tags</code>. 这个tag让我们可以在<code>.gitlab-ci.yml</code>通过配置来决定本次提交由哪个<code>runner</code>来执行文件中的脚本</li>
<li>选择<code>executor</code>. 这个我选择的是<code>shell</code>。目的是为了能够在容器内跟宿主机的<code>docker</code>通信。</li>
</ol>
<h2 id="4-一些注意点"><a href="#4-一些注意点" class="headerlink" title="4. 一些注意点"></a>4. 一些注意点</h2><ol>
<li>由于<code>ci</code>脚本默认由<code>gitlab-runner</code>这个用户执行，而这个用户是没有权限访问<code>docker.sock</code>的。所以，需要将<code>docker</code>组添加到<code>gitlab-runner</code>的附属组中。执行<code>usermod -aG docker gitlab-runner</code></li>
<li>如果依赖管理插件用的<code>gradle</code>,那么通常还需要<code>java</code>环境。<br>这个可以考虑把宿主机的<code>java</code>目录挂载进来<br>再在容器内配置<code>java</code>环境变量。或者也可以考虑重新安装</li>
<li>如果用到了<code>docker-compose</code>，也需要在容器内安装：<code>apt-get install -y docker-compose</code></li>
</ol>
<h1 id="编写-gitlab-ci-yml"><a href="#编写-gitlab-ci-yml" class="headerlink" title="编写.gitlab-ci.yml"></a>编写.gitlab-ci.yml</h1><p>先上一个案例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line">	<span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">	<span class="attr">only:</span> <span class="string">xxx</span></span><br><span class="line">	<span class="attr">tags:</span> <span class="string">defined</span> <span class="string">in</span> <span class="string">gitlab-runner</span></span><br><span class="line">	<span class="attr">before_script:</span> <span class="string">do</span> <span class="string">something</span></span><br><span class="line">	<span class="attr">script:</span> </span><br><span class="line">	<span class="attr">after_script:</span> </span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">	<span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">	<span class="attr">allow_failure:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">only:</span> </span><br><span class="line">		<span class="attr">changes:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">&quot;xxx.yaml&quot;</span></span><br><span class="line"><span class="attr">job3:</span></span><br><span class="line">	<span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">	<span class="attr">only:</span> </span><br><span class="line">		<span class="attr">refs:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">		<span class="attr">changes:</span> </span><br><span class="line">			<span class="bullet">-</span> <span class="string">&quot;service-one/*&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-stages"><a href="#1-stages" class="headerlink" title="1. stages"></a>1. <a href="https://docs.gitlab.com/ee/ci/yaml/#stages">stages</a></h2><ul>
<li>stages指定了ci job可能有的几个阶段。如果我们不指定，默认为build,test,deply。</li>
<li>其定义的顺序决定了job执行的顺序。所以我们在定义有依赖关系的job时，如果其对应的</li>
<li>stage本身的顺序跟job的依赖顺序是一致的，就可以省略掉dependencies的定义。</li>
<li>比如案例中的job2将在job1之后执行，与job的定义顺序无关，取决于stage的定义顺序。</li>
</ul>
<h2 id="2-job"><a href="#2-job" class="headerlink" title="2. job"></a>2. job</h2><ul>
<li>上述job1跟job2定义了两个job，job1是job的名字。</li>
<li>只要不把job名设置为像stages这种关键字就没没问题。</li>
</ul>
<h2 id="3-stage"><a href="#3-stage" class="headerlink" title="3. stage"></a>3. <a href="https://docs.gitlab.com/ee/ci/yaml/#stage">stage</a></h2><p>   指定当前job的阶段。注意，所有<code>stage</code>相同的<code>job</code>是可以并行运行的。<br>   这个并行数取决于<code>gitlab-runner</code>的配置文件<code>config.toml</code>中的<code>concurrent</code>来设置</p>
<h2 id="4-only"><a href="#4-only" class="headerlink" title="4. only"></a>4. <a href="https://docs.gitlab.com/ee/ci/jobs/job_control.html#only-variables--except-variables-examples">only</a></h2><p>   这个就是指明在什么情况下触发CI。比如，</p>
<ul>
<li>only后直接跟一个值(only: xxx)，则表示应用到哪个分支</li>
<li>only下的子项changes则表明哪里有变化(文件或者目录)则触发CI</li>
<li>only下的子项refs表明应用到哪个分支或者mr（值为merge_requests时）</li>
</ul>
<h2 id="5-tags"><a href="#5-tags" class="headerlink" title="5. tags"></a>5. <a href="https://docs.gitlab.com/ee/ci/yaml/#tags">tags</a></h2><p>   指定执行脚本的gitlab-runner。这个tag必须是gitlab-runner注册是填的tag</p>
<h2 id="6-allow-failure"><a href="#6-allow-failure" class="headerlink" title="6. allow_failure"></a>6. <a href="https://docs.gitlab.com/ee/ci/yaml/#allow_failure">allow_failure</a></h2><p>  <code> job</code>执行失败时是否影响后续的<code>job</code>执行。默认<code>false</code><br>   <code>true</code>表示当前<code>job</code>执行失败不影响后续的<code>job</code>执行<br>   <code>false</code>表示当前job执行失败则终端整个<a href="https://docs.gitlab.com/ee/ci/pipelines/">pipline</a>(所有的<code>job</code>跟<code>stage</code>组成的流程)</p>
<h2 id="7-before-script、script、after-script"><a href="#7-before-script、script、after-script" class="headerlink" title="7. before_script、script、after_script"></a>7. <a href="https://docs.gitlab.com/ee/ci/yaml/#before_script">before_script</a>、<a href="https://docs.gitlab.com/ee/ci/yaml/#script">script</a>、<a href="https://docs.gitlab.com/ee/ci/yaml/#after_script">after_script</a></h2><p>   执行顺序从前到后。用法通常为<br>  <code> before_script</code>: 初始化工作<br>  <code> script</code>: 主体脚本<br>  <code> after_script</code>: 收尾工作</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>GC调优之避免临时对象进入老年代思路浅析</title>
    <url>/posts/8ccc4590/</url>
    <content><![CDATA[<h3 id="什么是临时对象？"><a href="#什么是临时对象？" class="headerlink" title="什么是临时对象？"></a>什么是临时对象？</h3><ol>
<li>顾名思义，临时对象就是不能长期存活的对象，那么，怎么判断这个临时性呢？</li>
<li>从代码层来看，这个临时对象通常是指一些局部变量</li>
<li>对象有个属性叫分代年龄。分代年龄的值代表着这个对象经历的gc次数。在survivor区域不溢出的情况下经过有限次（默认是15次，具体要看系统实例情况，比如如果系统里年轻代大部分对象的分代年龄超过5就不太可能被回收，就可以认为分代年龄小于5的对象为临时对象）minor gc就能被回收的对象<h3 id="临时对象进入看年代有什么后果"><a href="#临时对象进入看年代有什么后果" class="headerlink" title="临时对象进入看年代有什么后果"></a>临时对象进入看年代有什么后果</h3><ol>
<li>顾名思义，老年代是用来存放那些分代年龄较大的对象（能够长时间存活）。临时对象进入老年代，意味着老年代浪费了部分内存空间来存储无用的数据，最终导致full gc会更频繁的发生。而对老年代进行垃圾收集的成本相对minor gc好很多，有stop the world的过程，同时gc线程也会占用cpu资源。这些最终也导致了系统性能降低<h3 id="怎么避免临时对象进入老年代"><a href="#怎么避免临时对象进入老年代" class="headerlink" title="怎么避免临时对象进入老年代"></a>怎么避免临时对象进入老年代</h3></li>
</ol>
</li>
<li>调整对象进入老年代的分代年龄的阈值</li>
<li>避免survivor区域的溢出（溢出会导致所有年轻代的对象直接进入老年代）</li>
<li> 上述两种思路需要根据系统实际负载来调整分代年龄阈值跟年轻代各区域的大小</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>jvm</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql之浅析AUTO_INCREMENT</title>
    <url>/posts/34050/</url>
    <content><![CDATA[<p><code>AUTO_INCREMENT</code>用于为表中的列设置一个自增序列，在非集群模式下，用它来为主键列自动生成值是一件很方便的事。并且，Mysql提供了一系列的锁机制来保证它的性能跟可靠性，通过这些锁机制，我们可以让它变得很高效。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>先来了解后面将要用到的术语。</p>
<ul>
<li>Simple inserts  能预先知道插入行数的语句。比如说单行插入（不包括<a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">INSERT … ON DUPLICATE KEY UPDATE</a>），不带子句的多行插入（自增列不赋值或全赋值）。</li>
<li>Bulk inserts  不能能预先知道插入行数的语句。比如<a href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html">INSERT … SELECT</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">REPLACE … SELECT</a> 。这种模式下，<code>InnoDB</code> 会在处理时为每一行的自增列一次分配一个自增值</li>
<li>Mixed-mode inserts  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
  <a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">INSERT … ON DUPLICATE KEY UPDATE</a></li>
<li>Insert-like  以上所有插入语句的统称</li>
</ul>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>锁模式在启动时通过<code>innodb_autoinc_lock_mode</code>这个变量来配置，它有3个值：<code>0, 1, 2</code>。分别对应<code>traditional</code>(传统)、<code>consecutive</code>(连续)、<code>interleaved</code>(交错)3种模式。</p>
<p>在<code>Mysql5.6~5.7</code>里，这个配置项的默认值是<code>1</code>，从<code>Mysql8</code>开始，它的默认值<code>2</code>。这个一方面是因为模式<code>2</code>的性能更好，另一方面是因为从<code>Mysql8</code>开始，默认的主从复制的方式由<code>statement-based</code> 改为了<code>row based</code>。<code>row based</code> 能保证<code>innodb_autoinc_lock_mode=2</code>时主从复制时的数据不会出现不一致的问题。好了，下面开始详细了解这三种锁模式吧！</p>
<ul>
<li>traditional  在这种模式下，Mysql所有的<code>Insert-like</code>操作都会设置一个表级别的<code>AUTO-INC</code> 锁，这个锁会在单条语句执行完毕时释放。  也就是说，如果有多个事务同时对同一张表执行<code>Insert-like</code> 操作，那么，即使它们没有操作同一条记录，也会串行执行。所以，它的性能相对另外两种模式来说会比较糟糕。</li>
<li>consecutive  在这种模式下，对于<code>Simple inserts</code>语句，<code>Mysql</code>会在语句执行的初始阶段将一条语句需要的所有自增值会一次性分配出来，并且通过设置一个互斥量来保证自增序列的一致性，一旦自增值生成完毕，这个互斥量会立即释放，不需要等到语句执行结束。  所以，在<code>consecutive</code>模式，多事务并发执行<code>Simple inserts</code>这类语句时， 相对traditional模式，性能会有比较大的提升。  由于一开始就为语句分配了所有需要的自增值，那么对于像<code>Mixed-mode inserts</code>这类语句，就有可能多分配了一些值给它，从而导致自增序列出现”<strong>空隙</strong>“。而<code>traditional</code>模式因为每一次只会为一条记录分配自增值，所有不会有这种问题。  另外，对于<code>Bulk inserts</code>语句，依然会采取<code>AUTO-INC</code>锁。所以，如果有一条<code>Bulk inserts</code>语句正在执行的话，<code>Simple inserts</code>也必须等到该语句执行完毕才能继续执行。</li>
<li>interleaved  在这种模式下，对于所有的<code>Insert-like</code>语句，都不会存在表级别的<code>AUTO-INC</code>锁，意味着同一张表上的多个语句并发时阻塞会大幅减少。  但是，这种模式必须运行在<code>row based</code>或者<code>mixed-format</code>(其实说白了也是row based，只不过mysql会根据自增模式为不安全的语句自动选择row based模式)复制模式下。因为<code>interleaved</code>这种模式下对于相同顺序的语句每次执行行都会产生不同的结果(谁竞争到<strong>互斥量</strong>，谁就能获得生成自增值的权利)，所以，如果复制模式是<code>statement-based</code>或者通过<code>binlog</code>进行数据恢复时(牵扯到binlog的语句重放)，可能会导致数据不一致。</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>自增值的生成后是不能回滚的，所以自增值生成后，事务回滚了，那么那些已经生成的自增值就丢失了，从而使自增列的数据出现空隙</li>
<li>正常情况下，自增列是不存在<code>0</code>这个值的。所以，如果插入语句中对自增列设置的值为<code>0</code>或者<code>null</code>，就会自动应用自增序列。  那么，如果想在自增列中插入为0这个值，怎么办呢？可以通过将<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_auto_value_on_zero">SQL Mode</a>设置为<code>NO_AUTO_VALUE_ON_ZERO</code>即可</li>
<li>在Mysql5.7以及更早之前，自增序列的计数器(<code>auto-increment counter</code>)是保存在内存中的。<code>auto-increment counter</code>在每次Mysql重新启动后通过类似下面的这种语句进行初始化：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(AUTO_INC_COLUMN) <span class="keyword">FROM</span> table_name <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure>
  而从<code>Mysql8</code>开始，<code>auto-increment counter</code>被存储在了<code>redo log</code>中，并且每次变化都会刷新到<code>redo log</code>中。另外，我们可以通过<a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html">ALTER TABLE … AUTO_INCREMENT = N</a> 来主动修改<br>  <code>auto-increment counter</code>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>单实例下，可以设置<code>innodb_autoinc_lock_mode=2</code></li>
<li>主从<ol>
<li>复制模式为<code>statement-based</code>，设置<code>innodb_autoinc_lock_mode=1</code></li>
<li>复制模式为<code>row based</code>或者<code>mixed-format</code>，设置<code>innodb_autoinc_lock_mode=2</code></li>
</ol>
</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><strong><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-mode-usage-implications">15.6.1.6 AUTO_INCREMENT Handling in InnoDB</a></strong></strong></li>
<li><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-recovery.html">15.18.2 InnoDB Recovery</a></strong></li>
<li><strong><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/replication-features-auto-increment.html">17.5.1.1 Replication and AUTO_INCREMENT</a></strong></strong></li>
<li><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html">3.6.9 Using AUTO_INCREMENT</a></strong></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql之浅析INSERT ON DUPLICATE</title>
    <url>/posts/34049/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果不特别指出，默认mysql版本为8.0</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>往数据库中插入记录时，如果发生唯一索引值冲突，insert on duplicate允许进行进一步的crud操作。伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert record</span><br><span class="line">IF exist duplicate record THEN</span><br><span class="line">  do something on duplicated rows</span><br><span class="line">ELSE </span><br><span class="line">  do nothing</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>
<h1 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h1><p>先初始化将要用到的表跟数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1</span><br><span class="line">(</span><br><span class="line">    id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    a  <span class="type">integer</span> <span class="keyword">unique</span>,</span><br><span class="line">    b  <span class="type">integer</span> <span class="keyword">default</span> <span class="number">999</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_insert_on_dup_update(id, a)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_insert_on_dup_update(id, a)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_insert_on_dup_update(id, a)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="1-单个唯一索引插入冲突"><a href="#1-单个唯一索引插入冲突" class="headerlink" title="1. 单个唯一索引插入冲突"></a>1. 单个唯一索引插入冲突</h2><p>通过如下sql进行数据插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t1(a,b) values(1,199) on duplicate update b = 1;</span><br></pre></td></tr></table></figure>
<p>因为表中已经存在<strong>a=1</strong>的记录，这个时候会触发on duplicate后面的update操作，将a=1的记录的b从999修改为1.</p>
<p><strong>在这种情况下，上面的sql等价于</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update b<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-多个唯一索引插入冲突"><a href="#1-2-多个唯一索引插入冲突" class="headerlink" title="1.2 多个唯一索引插入冲突"></a>1.2 多个唯一索引插入冲突</h2><p>如果插入的记录与a跟b上的索引值都发生了冲突，且发生冲突的记录有多条会怎么样呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">5</span>) </span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>因为a=1跟b=5都存在，这个时候<strong>有两行记录与即将插入的记录有冲突</strong>。按照<a href="#%E7%AE%80%E4%BB%8B">前面</a>介绍的规则来看，貌似<strong>id=1</strong>跟<strong>a=5</strong>这两条记录的<code>b</code>都会被更新成1。但事实是只有一条有冲突的记录会应用<code>on duplicate</code>后面的子句。而这条被命中记录就是<strong>在所有满足条件的记录中</strong>，其<strong>id值</strong>在<strong>聚集索引叶节点的链表中最靠前的那条记录</strong>。在本例中也就是id=1的那条记录。该sql的实际效果等价于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update t1 <span class="keyword">set</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> a<span class="operator">=</span><span class="number">5</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所以，当发生这种情况时，我们很难去预料语句的行为。<strong>应当尽量避免这种情况</strong>。</p>
<h2 id="1-3-子句获取插入列即将插入的值"><a href="#1-3-子句获取插入列即将插入的值" class="headerlink" title="1.3 子句获取插入列即将插入的值"></a>1.3 子句获取插入列即将插入的值</h2><h3 id="在8-0-19之前"><a href="#在8-0-19之前" class="headerlink" title="在8.0.19之前"></a>在8.0.19之前</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">5</span>) </span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> <span class="keyword">values</span>(a);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">5</span>) </span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><code>values(a)</code>获取的是原本准备插入的<code>a=5</code>这个值.</p>
<p>要注意的是：<strong>这种写法将在8.0.20版本被废弃，对应的功能在未来会被移除。</strong></p>
<h3 id="在8-0-19之后"><a href="#在8-0-19之后" class="headerlink" title="在8.0.19之后"></a>在8.0.19之后</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">as</span> <span class="keyword">new</span></span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> new.a;</span><br></pre></td></tr></table></figure>
<p>这里为新插入的记录设置了一个别名<code>new</code>，通过这个别名可以获取到准备插入的数据。另外，还可以基于这个别名更进一步的为里面的每个列设置别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">as</span> <span class="keyword">new</span>(x,y)</span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-根据查询结果进行插入"><a href="#1-4-根据查询结果进行插入" class="headerlink" title="1.4 根据查询结果进行插入"></a>1.4 根据查询结果进行插入</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(id, a) <span class="keyword">select</span> x,y <span class="keyword">from</span> t2</span><br><span class="line">  <span class="keyword">on</span> duplicate update b <span class="operator">=</span> x</span><br></pre></td></tr></table></figure>
<p>像这类语句，由于插入的顺序依赖于select的结果集里行的顺序，而mysql不能保证这个select的结果集在主从上的顺序是完全一致的，这就会导致基于statement的主从复制会出现数据不一致的问题。而基于行的复制模式不存在这个问题。所以，如果存在这类子句中带<code>select</code>的sql，注意将复制模式设置为<code>row-based</code>或者<code>mixed</code></p>
<h1 id="跟锁相关的部分"><a href="#跟锁相关的部分" class="headerlink" title="跟锁相关的部分"></a>跟锁相关的部分</h1><p>根据不同的隔离级别，有如下特征：</p>
<ol>
<li><p><code>repeatable read</code></p>
<ul>
<li>  普通唯一索引（非主键）发生唯一key冲突，这种情况会锁住该索引以及聚集索引。</li>
<li>  主键值发生冲突。则会为发生冲突的主键值设置<strong>行锁</strong>。</li>
</ul>
</li>
<li><p> <code>READ COMMITTED</code>：会为冲突的索引值设置行锁</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码浅析之@Autowired如何解决循环依赖</title>
    <url>/posts/f0ea53d7/</url>
    <content><![CDATA[<h1 id="Autowired的what-amp-how"><a href="#Autowired的what-amp-how" class="headerlink" title="@Autowired的what&amp;how"></a>@Autowired的what&amp;how</h1><p>在spring框架下，我们可以通过<code>@Autowired</code>注解对==属性==或者==方法参数==进行标注，当<code>spring ioc</code>容器初始化时，会帮我们从容器中拿到对应的实例进行注入</p>
<h1 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h1><p>假如现在有两个<code>Bean</code>如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们通过<code>annotationConfigApplicationContext#register</code>将两个<code>bean</code>的信息注入到容器中，最后通过<code>refresh</code>进行容器到初始化操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        annotationConfigApplicationContext.register(Bean1.class);</span><br><span class="line">        annotationConfigApplicationContext.register(Bean2.class);</span><br><span class="line">        annotationConfigApplicationContext.refresh();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到A跟B互相依赖，试着想象：当容器先初始化<code>beanA</code>时，必然要对属性beanB进行赋值，这个时候容器中还没有<code>beanB</code>，那么势必会触发<code>beanB</code>的初始化流程，而<code>beanB</code>初始化的完成也需要对属性<code>beanA</code>赋值，但<code>beanA</code>还未初始化完成，这里就产生了所谓的循环依赖。</p>
<h1 id="spring如何解决循环依赖"><a href="#spring如何解决循环依赖" class="headerlink" title="spring如何解决循环依赖"></a>spring如何解决循环依赖</h1><p>这里有一个很关键的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key是beanName，value是一个对象工厂，我们点进去看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里的getObject()就是最终解决循环依赖所调用的方法。<br>那么程序是怎样执行到这的呢？<br>我们先从bean的创建入手<br>如果容器还未实例化bean，那么就会走到这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//实例化bean，如果@Autowired加在构造方法上，</span></span><br><span class="line">			<span class="comment">//那么就会在这里完成注入</span></span><br><span class="line">			<span class="comment">//因为下面的回调还未注册，所以这里无法解决循环依赖</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//往单例工厂(之前说的singletonFactories)中添加一个</span></span><br><span class="line">			<span class="comment">//ObjectFactory的匿名实现作为回调，</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//属性赋值，处理@Autowired(非构造方法)</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现，在实例化<code>bean</code>跟对属性赋值之间有一个<code>addSingletonFactory</code>的操作，作用是注册一个可以获取当前正在创建的<code>bean</code>的一个回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入回调，发现回调默认返回的就是<code>bean</code>本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//	返回bean本身</span></span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，这里得出一个结论，即使<code>bean</code>未初始化完成，<code>spring</code>也提供了方法来获取这个<code>bean</code>的实例。<br>如果应用到我们上面的栗子中来就是：</p>
<ol>
<li><code>beanA</code>实例化完成</li>
<li>添加获取<code>beanA</code>的回调到<code>singletonFactories</code></li>
<li>调用<code>populateBean</code>，处理<code>@Autowired</code>，注入<code>beanB</code></li>
</ol>
<p>因为<code>beanB</code>还未创建，那么势必会进入创建<code>beanB</code>的流程，当<code>beanB</code>也走到<code>populateBean</code>时，也需要完成<code>beanA</code>的注入，这时就会尝试从<code>beanFactory</code>中获取<code>beanA</code>，这里最终会进到<br><code>AbstractBeanFactory</code>的<code>doGetBean</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很关键，进入<code>getSingleton(beanName)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">	Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">//拿到之前注册的单例工厂对象</span></span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">				    <span class="comment">//调用之前注册的回调</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当beanB走到这里时通过<code>beanA</code>的<code>beanName</code>获取<code>beanA</code>，首先会尝试从<code>singletonObjects</code>中获取，这里肯定获取不到，因为<code>singletonObjects</code>的<code>put</code>操作是在<code>bean</code><strong>初始化</strong>完成之后。所以只能通过调用之前注册的回调<code>singletonFactory.getObject()</code>来获取<code>beanA</code>。<br>那么到此<code>beanA</code>注入到<code>beanB</code>的顺利完成，当<code>beanB</code>初始化完成之后，其实<code>beanA</code>的<code>getBean()</code>也就返回了<code>beanB</code>的引用，到此<code>beanA</code>也可以顺利完成依赖注入。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>源码</tag>
        <tag>spring</tag>
        <tag>浅析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码浅析之事物管理</title>
    <url>/posts/992afad8/</url>
    <content><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li> <strong>spring是怎样帮助我们进行事务管理的</strong></li>
<li> <strong>spring是如何实现事务的传播的</strong></li>
</ul>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>spring声明式事务需要aop的支持，在spring容器初始化的时候，会将一个TransactionInterceptor的实例注入到所有方法上加了@Transactional注解的bean的代理对象的advisor数组中，当我们执行事务方法时，就会去执行TransactionInterceptor.invoke方法进行事务处理</p>
<h1 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h1><h2 id="注入TransactionInterceptor的过程参考"><a href="#注入TransactionInterceptor的过程参考" class="headerlink" title="注入TransactionInterceptor的过程参考"></a>注入TransactionInterceptor的过程参考</h2><p>1. 首先初始化所有Advisor，这个过程会把容器中实现了advisor接口的beanDefinition对应的类实例化并加入到一个AdvisedSupport对象中，最后会注入到代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutoProxyCreator.postProcessBeforeInstantiation()</span><br><span class="line"></span><br><span class="line">    ---&gt;AspectJAwareAdvisorAutoProxyCreator.shouldSkip()</span><br><span class="line"></span><br><span class="line">       ---&gt;AspectJAwareAdvisorAutoProxyCreator.findCandidateAdvisors() </span><br></pre></td></tr></table></figure>
<p>2. 代理bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutoProxyCreator.postProcessAfterInitialization()</span><br><span class="line"></span><br><span class="line">     --&gt;AbstractAutoProxyCreator.wrapIfNecessary()</span><br><span class="line">         <span class="comment">//这里面会去选择使用jdk或者cglib进行代理对象的创建</span></span><br><span class="line">         --&gt;AbstractAutoProxyCreator.createProxy()</span><br></pre></td></tr></table></figure>
<h2 id="TransactionInterceptor类图"><a href="#TransactionInterceptor类图" class="headerlink" title="TransactionInterceptor类图"></a>TransactionInterceptor类图</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwOTUzOC0xZDkwNmIxNjgwMGVhOGExLnBuZw?x-oss-process=image/format,png" alt="TransactionInterceptor类图.png"><br>这里可以到到TransactionInterceptor最终是实现了Avice接口，所以在前面的1中就会把TransactionInterceptor实例化好作为拦截器注入到代理对象中</p>
<h1 id="事务处理流程"><a href="#事务处理流程" class="headerlink" title="事务处理流程"></a>事务处理流程</h1><h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><h3 id="invokeWithinTransaction"><a href="#invokeWithinTransaction" class="headerlink" title="invokeWithinTransaction()"></a>invokeWithinTransaction()</h3><p>当我们调用加了@Transactional的bean的目标方法时，首先会进入TransactionInterceptor.invoke，这里是因为TransactionInterceptor实现了MethodInterceptor（具体可参考spring aop原理）。然后会调用TransactionAspectSupport.invokeWithinTransaction()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">        <span class="comment">//初始化事务所需要的所有信息到txInfo，包括隔离级别，数据源等</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        Object retVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//继续执行后续的拦截器，最终返回目标方法执行结果</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//异常回滚</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">//清除线程本地变量保存的事务信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无异常则commit</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="开启事务管理"><a href="#开启事务管理" class="headerlink" title="开启事务管理"></a>开启事务管理</h2><h3 id="createTransactionIfNecessary"><a href="#createTransactionIfNecessary" class="headerlink" title="createTransactionIfNecessary()"></a>createTransactionIfNecessary()</h3><p>这里有个createTransactionIfNecessary(tm, txAttr, joinpointIdentification)方法，它保存了事务执行过程中所需要的全部信息，其内部会处理事务的传播，例如当propagation设置为REQUIRES_NEW时，它会去挂起当前事务，挂起主要是把当前事务的jdbc连接从线程的threadlocalMap中清除，并保存到新的事务的TransactionStatus中。然后把当前事务的transactionInfo保存到新建立的transactioninfo的oldTransactionInfo属性中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化事务的状态，后续提交跟回滚时会通过这个对象拿到这个事务的传播属性</span></span><br><span class="line">               <span class="comment">//处理事务的传播属性</span></span><br><span class="line">				status = tm.getTransaction(txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//初始化当前事务，并把当前事务加入到当前线程的threadLocalMap中</span></span><br><span class="line">        <span class="comment">//将先前的事务加入到当前事务的oldTransactionInfo属性中</span></span><br><span class="line">		<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>进入tm.getTransaction()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程绑定的transactionResource对象</span></span><br><span class="line">		Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">			definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果当前已经存在一个事务</span></span><br><span class="line">		<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">            <span class="comment">//处理事务的传播性</span></span><br><span class="line">			<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">					<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">			SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">						definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">                <span class="comment">//为当前session设置隔离级别，关闭自动提交</span></span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				<span class="keyword">return</span> status;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">				resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">			<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">						<span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">            <span class="comment">//构建transcationStatus对象</span></span><br><span class="line">			<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事务挂起"><a href="#事务挂起" class="headerlink" title="事务挂起"></a>事务挂起</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//把transaction中旧的连接信息包装返回，然后置空</span></span><br><span class="line">				suspendedResources = doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">			Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">//返回被挂起的连接信息</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">		Object suspendedResources = doSuspend(transaction);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Neither transaction nor synchronization active.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把旧的连接信息保存起来，并把当前transaction对象中的连接信息置空</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="comment">//防止重复提交事务</span></span><br><span class="line">	<span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用TransactionStatus.setRollbackOnly()会进入这个处理</span></span><br><span class="line">	<span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//像内部REQUIRED的方法抛出异常回滚，会设置ResourceHolderSupport.rollbackOnly为true，</span></span><br><span class="line">	<span class="comment">//如果外部事务方法catch这个异常</span></span><br><span class="line">	<span class="comment">//外部方法就会尝试提交事务并最终走到这</span></span><br><span class="line">	<span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">		beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">			<span class="comment">//删除savepoint</span></span><br><span class="line">			status.releaseHeldSavepoint();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//像REQURED传播性，这个值就为false，</span></span><br><span class="line">		<span class="comment">//保证了内部RUQUIRED方法不会触发事务提交</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">			<span class="comment">//提交事务</span></span><br><span class="line">			doCommit(status);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">			unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//还原当前session，</span></span><br><span class="line">		<span class="comment">//把之前被挂起的连接信息重新设置到当前线程的threadLocalMap中</span></span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果业务方法没有抛出异常，最终会调用commit</p>
<h2 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//回滚事务至savepoint并清除savepoint</span></span><br><span class="line">				status.rollbackToHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				doRollback(status);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果传播级别是RUQUIRED</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Participating in larger transaction</span></span><br><span class="line">				<span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">						<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">//设置状态，commit的时候rollbackOnly为true会触发回滚</span></span><br><span class="line">						doSetRollbackOnly(status);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">					unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们会发现一个小细节，当外部带事务的方法调用了传播性为REQUIRED的内部方法，如果内部方法抛异常了，这个时候内部方法的事务管理在catch到异常之后，只会设置一个回滚标志位，等到外部方法去提交时，再出发回滚</p>
<h2 id="TransactionStatus-isNewTransaction"><a href="#TransactionStatus-isNewTransaction" class="headerlink" title="TransactionStatus.isNewTransaction"></a>TransactionStatus.isNewTransaction</h2><p>这个值很重要，直接决定了事务能否提交与回滚，REQUIRED,SUPPORTS,NESTED就需要依赖这个来实现传播</p>
<h2 id="finally处理–cleanupTransactionInfo"><a href="#finally处理–cleanupTransactionInfo" class="headerlink" title="finally处理–cleanupTransactionInfo"></a>finally处理–cleanupTransactionInfo</h2><p>最后执行完目标方法回到invokeWithinTransaction，我们来看看finally里的cleanupTransactionInfo()做了什么事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanupTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (txInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			txInfo.restoreThreadLocalStatus();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">			<span class="comment">// Will be null if none was set.</span></span><br><span class="line">			transactionInfoHolder.set(<span class="keyword">this</span>.oldTransactionInfo);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current aspect-driven transaction&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们发现，它把先前内层事务（如果存在）保存下来的事务信息重新设置到了当前线程的threadlocalMap中，这里主要在TransactionAspectSupport.currentTransactionStatus()可以获取到这个transactionInfo的status属性</p>
<h1 id="传播属性"><a href="#传播属性" class="headerlink" title="传播属性"></a>传播属性</h1><p>代码段来自AbstractPlatformTransactionManager类的getTransaction  &amp;handleExistingTransaction()</p>
<h2 id="核心源码预览"><a href="#核心源码预览" class="headerlink" title="核心源码预览"></a>核心源码预览</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="comment">//如果当前不存在事务，且传播属性是这些，就开启一个新的事务</span></span><br><span class="line">	<span class="comment">//否则啥都不做</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">					<span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">		<span class="comment">//如果当前存在事务，newSynchronization设置为false</span></span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">					<span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>进入handleExistingTransaction的条件是当前已经存在一个事务，所以这里可以看出，NERVER不能运行在一个已经存在的事务里，同时在getTransaction()方法内不会去关闭事务的自动提交，这就意味着spring==不会帮我们去控制事务的提交与回滚==</p>
<h2 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//挂起已存在的事务</span></span><br><span class="line">	Object suspendedResources = suspend(transaction);</span><br><span class="line">	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">	<span class="comment">//第三个参数为false，控制了spring后面不会去调用真正的事务提交方法</span></span><br><span class="line">	<span class="comment">//可参考AbstractPlatformTransactionManager#741行</span></span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">			definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们可以知道，NOT_SUPPORTED就是说，如果当前方法已经存在一个事务中，就会挂起当前事务，无论如何，被这个标注的方法，spring都不会去进行事务管理，但是，它与NERVER的区别是，不会抛出异常<br>挂起主要是保存当前事务的jdbc连接信息到TranscationStatus中<br>把当前线程的threadlocalMap里的连接信息切换成新的连接信息</p>
<h2 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">				definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//挂起已存在的事务</span></span><br><span class="line">	SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		<span class="comment">//参数3为true意味着对应的事务可用自主提交</span></span><br><span class="line">		DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">				definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">		<span class="comment">//拿到新的连接，设置隔离级别，关闭自动提交</span></span><br><span class="line">		doBegin(transaction, definition);</span><br><span class="line">		prepareSynchronization(status, definition);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">		resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">		<span class="keyword">throw</span> beginEx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前已存在事务，则挂起当前事务，开启一个新的事务</p>
<h2 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">//是否通过安全点实现嵌套事务，默认是</span></span><br><span class="line">		<span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">			<span class="comment">//没有挂起当前事务，说明当前方法跟外层方法在同一个session里</span></span><br><span class="line">			<span class="comment">//第3个参数为false意味着当前方法最后不会触发事务的全局commit跟rollback</span></span><br><span class="line">			DefaultTransactionStatus status =</span><br><span class="line">					prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">//创建一个savepoint，如果后面业务出异常，(mysql语法：savepoint + name)</span></span><br><span class="line">			<span class="comment">//spring会自动帮助我们把事务回滚到这个savepoint</span></span><br><span class="line">			status.createAndHoldSavepoint();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不使用savepoint，就通过内部加嵌套的begin跟commit/rollback</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//回滚处理</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			<span class="comment">//如果有savepoint</span></span><br><span class="line">			<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//事务回滚至savepoint</span></span><br><span class="line">				status.rollbackToHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				doRollback(status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">			prepareForCommit(status);</span><br><span class="line">			triggerBeforeCommit(status);</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				<span class="comment">//删除savepoint</span></span><br><span class="line">				status.releaseHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				doCommit(status);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，嵌套事务利用了savepoint，内部事务不会commit，如果发生异常，只会把事务rollback至创建的savepoint</p>
<h2 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里很明显，如果当前方法没有运行在一个已存在的事务内，就会抛异常</p>
<h2 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h2><h2 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前不存在事务，并且传播机制是这几种</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">		definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">		definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">	SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">				definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">		<span class="comment">//开启事务管理</span></span><br><span class="line">		doBegin(transaction, definition);</span><br><span class="line">		prepareSynchronization(status, definition);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">		resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不参与事务管理</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出，如果当前已存在事务，REQUIRED跟SUPPORTS的处理方式都是延用当前事务，但是如果当前不存在事务，REQUIRED会开启一个事务管理，SUPPORTS则不做任何处理，spring不介入事务处理</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring声明式事务通过AOP注入TranscationInterceptor生成代理对象来对目标方法进行拦截，通过关闭db事务的自动提交来介入事务管理，并在内部对事务的传播做了一系列的控制</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s</title>
    <url>/posts/655061ae/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>seata源码分析之全局事务的开启跟xid的传递</title>
    <url>/posts/b310611e/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h3 id="首先我们通过-GlobalTransactional这个注解开启一个全局事务，而GlobalTransactionScanner-wrapIfNecessary-会为所有方法上加了这个注解的bean注入一个包装了GlobalTransactionalInterceptor实例的advisor，然后返回一个代理对象。GlobalTransactionalInterceptor会在该bean的方法调用前进行拦截，判断是否开启全局事务"><a href="#首先我们通过-GlobalTransactional这个注解开启一个全局事务，而GlobalTransactionScanner-wrapIfNecessary-会为所有方法上加了这个注解的bean注入一个包装了GlobalTransactionalInterceptor实例的advisor，然后返回一个代理对象。GlobalTransactionalInterceptor会在该bean的方法调用前进行拦截，判断是否开启全局事务" class="headerlink" title="首先我们通过@GlobalTransactional这个注解开启一个全局事务，而GlobalTransactionScanner.wrapIfNecessary()会为所有方法上加了这个注解的bean注入一个包装了GlobalTransactionalInterceptor实例的advisor，然后返回一个代理对象。GlobalTransactionalInterceptor会在该bean的方法调用前进行拦截，判断是否开启全局事务"></a>首先我们通过@GlobalTransactional这个注解开启一个全局事务，而GlobalTransactionScanner.wrapIfNecessary()会为所有方法上加了这个注解的bean注入一个包装了GlobalTransactionalInterceptor实例的advisor，然后返回一个代理对象。GlobalTransactionalInterceptor会在该bean的方法调用前进行拦截，判断是否开启全局事务</h3><p>上源码，关键位置我打了注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">    //判断全局事务是否启用</span><br><span class="line">    if (disableGlobalTransaction) &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (PROXYED_SET) &#123;</span><br><span class="line">            if (PROXYED_SET.contains(beanName)) &#123;</span><br><span class="line">                return bean;</span><br><span class="line">            &#125;</span><br><span class="line">            interceptor = null;</span><br><span class="line">            //check TCC proxy</span><br><span class="line">            if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) &#123;</span><br><span class="line">                //TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC</span><br><span class="line">                interceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Class&lt;?&gt; serviceInterface = SpringProxyUtils.findTargetClass(bean);</span><br><span class="line">                Class&lt;?&gt;[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean);</span><br><span class="line"></span><br><span class="line">                //判断bean里的方法上有没有@GlobalTransactional注解</span><br><span class="line">                if (!existsAnnotation(new Class[]&#123;serviceInterface&#125;)</span><br><span class="line">                    &amp;&amp; !existsAnnotation(interfacesIfJdk)) &#123;</span><br><span class="line">                    return bean;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (interceptor == null) &#123;</span><br><span class="line">                    //初始化Interceptor,后面会注入代理对象</span><br><span class="line">                    interceptor = new GlobalTransactionalInterceptor(failureHandlerHook);</span><br><span class="line">                    ConfigurationFactory.getInstance().addConfigListener(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION, (ConfigurationChangeListener) interceptor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断当前bean是否已被aop代理过，比如说方法上加了@Transactional就会被spring代理</span><br><span class="line">            //如果没有被代理，调用父类的模板方法进行代理，advisor通过被重写的</span><br><span class="line">            //getAdvicesAndAdvisorsForBean返回上面的interceptor进行包装</span><br><span class="line">            if (!AopUtils.isAopProxy(bean)) &#123;</span><br><span class="line">                bean = super.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                AdvisedSupport advised = SpringProxyUtils.getAdvisedSupport(bean);</span><br><span class="line"></span><br><span class="line">                //把GlobalTransactionalInterceptor包装成advisor</span><br><span class="line">                Advisor[] advisor = buildAdvisors(beanName, getAdvicesAndAdvisorsForBean(null, null, null));</span><br><span class="line">                for (Advisor avr : advisor) &#123;</span><br><span class="line">                    advised.addAdvisor(0, avr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            PROXYED_SET.add(beanName);</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception exx) &#123;</span><br><span class="line">        throw new RuntimeException(exx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Object[] getAdvicesAndAdvisorsForBean(Class beanClass, String beanName,</span><br><span class="line">  TargetSource customTargetSource) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    //返回interceptor[]</span><br><span class="line">    return new Object[]&#123;interceptor&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        if (disableGlobalTransaction) &#123;</span><br><span class="line">            if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                LOGGER.info(&quot;Global transaction is disabled.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用netty初始化seata client，建立到server端的连接</span><br><span class="line">        initClient();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里可以看出来，只要我们在方法上加了@GlobalTranscational注解，对应的bean就会被seata进行代理，同时重写了afterPropertiesSet，在bean初始化完毕后会进行调用，这个client就是用来跟server端通信的，包括后面会说到的下游服务的事务提交与回滚都与这个有关</p>
<p>GlobalTransactionalInterceptor重写了MethodInterceptor的invoke()方法，在spring执行通知代理对象的通知方法时，最终会调用到这个invoke()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(final MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = methodInvocation.getThis() != null ?AopUtils.getTargetClass(methodInvocation.getThis()) : null;</span><br><span class="line">        Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);</span><br><span class="line">        final Method method = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line"></span><br><span class="line">        final GlobalTransactional globalTransactionalAnnotation = getAnnotation(method, GlobalTransactional.class);</span><br><span class="line">        final GlobalLock globalLockAnnotation = getAnnotation(method, GlobalLock.class);</span><br><span class="line">        //如果全局事务可用并且方法上加了@GlobalTransactional注解</span><br><span class="line">        if (!disable &amp;&amp; globalTransactionalAnnotation != null) &#123;</span><br><span class="line">            //处理全局事务</span><br><span class="line">            return handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);</span><br><span class="line">        &#125; else if (!disable &amp;&amp; globalLockAnnotation != null) &#123;</span><br><span class="line">            return handleGlobalLock(methodInvocation);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return methodInvocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里就会然后调用handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object handleGlobalTransaction(final MethodInvocation methodInvocation,</span><br><span class="line">                                           final GlobalTransactional globalTrxAnno) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return transactionalTemplate.execute(new TransactionalExecutor() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Object execute() throws Throwable &#123;</span><br><span class="line">                    return methodInvocation.proceed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public String name() &#123;</span><br><span class="line">                    String name = globalTrxAnno.name();</span><br><span class="line">                    if (!StringUtils.isNullOrEmpty(name)) &#123;</span><br><span class="line">                        return name;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return formatMethod(methodInvocation.getMethod());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public TransactionInfo getTransactionInfo() &#123;</span><br><span class="line">                    TransactionInfo transactionInfo = new TransactionInfo();</span><br><span class="line">                    transactionInfo.setTimeOut(globalTrxAnno.timeoutMills());</span><br><span class="line">                    transactionInfo.setName(name());</span><br><span class="line">                    transactionInfo.setPropagation(globalTrxAnno.propagation());</span><br><span class="line">                    Set&lt;RollbackRule&gt; rollbackRules = new LinkedHashSet&lt;&gt;();</span><br><span class="line">                    for (Class&lt;?&gt; rbRule : globalTrxAnno.rollbackFor()) &#123;</span><br><span class="line">                        rollbackRules.add(new RollbackRule(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (String rbRule : globalTrxAnno.rollbackForClassName()) &#123;</span><br><span class="line">                        rollbackRules.add(new RollbackRule(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (Class&lt;?&gt; rbRule : globalTrxAnno.noRollbackFor()) &#123;</span><br><span class="line">                        rollbackRules.add(new NoRollbackRule(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (String rbRule : globalTrxAnno.noRollbackForClassName()) &#123;</span><br><span class="line">                        rollbackRules.add(new NoRollbackRule(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    transactionInfo.setRollbackRules(rollbackRules);</span><br><span class="line">                    return transactionInfo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (TransactionalExecutor.ExecutionException e) &#123;</span><br><span class="line">            TransactionalExecutor.Code code = e.getCode();</span><br><span class="line">            switch (code) &#123;</span><br><span class="line">                case RollbackDone:</span><br><span class="line">                    throw e.getOriginalException();</span><br><span class="line">                case BeginFailure:</span><br><span class="line">                    failureHandler.onBeginFailure(e.getTransaction(), e.getCause());</span><br><span class="line">                    throw e.getCause();</span><br><span class="line">                case CommitFailure:</span><br><span class="line">                    failureHandler.onCommitFailure(e.getTransaction(), e.getCause());</span><br><span class="line">                    throw e.getCause();</span><br><span class="line">                case RollbackFailure:</span><br><span class="line">                    failureHandler.onRollbackFailure(e.getTransaction(), e.getCause());</span><br><span class="line">                    throw e.getCause();</span><br><span class="line">                case RollbackRetrying:</span><br><span class="line">                    failureHandler.onRollbackRetrying(e.getTransaction(), e.getCause());</span><br><span class="line">                    throw e.getCause();</span><br><span class="line">                default:</span><br><span class="line">                    throw new ShouldNeverHappenException(String.format(&quot;Unknown TransactionalExecutor.Code: %s&quot;, code));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里transactionalTemplate.execute（）传入了一个匿名实现，其execute()就是放行让后续的通知方法继续执行，这个我们不关心，进入transactionalTemplate.execute（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object execute(TransactionalExecutor business) throws Throwable &#123;</span><br><span class="line">        // 1 get transactionInfo</span><br><span class="line">        TransactionInfo txInfo = business.getTransactionInfo();</span><br><span class="line">        if (txInfo == null) &#123;</span><br><span class="line">            throw new ShouldNeverHappenException(&quot;transactionInfo does not exist&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 1.1 get or create a transaction</span><br><span class="line">        GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();</span><br><span class="line"></span><br><span class="line">        // 1.2 Handle the Transaction propatation and the branchType</span><br><span class="line">        Propagation propagation = txInfo.getPropagation();</span><br><span class="line">        SuspendedResourcesHolder suspendedResourcesHolder = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (propagation) &#123;</span><br><span class="line">                case NOT_SUPPORTED:</span><br><span class="line">                    suspendedResourcesHolder = tx.suspend(true);</span><br><span class="line">                    return business.execute();</span><br><span class="line">                case REQUIRES_NEW:</span><br><span class="line">                    suspendedResourcesHolder = tx.suspend(true);</span><br><span class="line">                    break;</span><br><span class="line">                case SUPPORTS:</span><br><span class="line">                    if (!existingTransaction()) &#123;</span><br><span class="line">                        return business.execute();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case REQUIRED:</span><br><span class="line">                    break;</span><br><span class="line">                case NEVER:</span><br><span class="line">                    if (existingTransaction()) &#123;</span><br><span class="line">                        throw new TransactionException(</span><br><span class="line">                                String.format(&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;,xid = %s&quot;</span><br><span class="line">                                        ,RootContext.getXID()));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return business.execute();</span><br><span class="line">                    &#125;</span><br><span class="line">                case MANDATORY:</span><br><span class="line">                    if (!existingTransaction()) &#123;</span><br><span class="line">                        throw new TransactionException(&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    throw new TransactionException(&quot;Not Supported Propagation:&quot; + propagation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                // 2. begin transaction</span><br><span class="line">                beginTransaction(txInfo, tx);</span><br><span class="line"></span><br><span class="line">                Object rs = null;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    // Do Your Business</span><br><span class="line">                    rs = business.execute();</span><br><span class="line"></span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line"></span><br><span class="line">                    // 3.the needed business exception to rollback.</span><br><span class="line">                    completeTransactionAfterThrowing(txInfo, tx, ex);</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 4. everything is fine, commit.</span><br><span class="line">                commitTransaction(tx);</span><br><span class="line"></span><br><span class="line">                return rs;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //5. clear</span><br><span class="line">                triggerAfterCompletion();</span><br><span class="line">                cleanUp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            tx.resume(suspendedResourcesHolder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里首先初始化一个GlobalTransaction实例tx，用于保存后续生成的xid跟事务状态等一些属性。然后对事务的传播属性做了些校验。然后我们进入beginTransaction(txInfo, tx);顾名思义，这里快要到核心了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void beginTransaction(TransactionInfo txInfo, GlobalTransaction tx) throws TransactionalExecutor.ExecutionException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行hook的begin()方法做一些额外处理</span><br><span class="line">            triggerBeforeBegin();</span><br><span class="line">            tx.begin(txInfo.getTimeOut(), txInfo.getName());</span><br><span class="line">            triggerAfterBegin();</span><br><span class="line">        &#125; catch (TransactionException txe) &#123;</span><br><span class="line">            throw new TransactionalExecutor.ExecutionException(tx, txe,</span><br><span class="line">                TransactionalExecutor.Code.BeginFailure);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里的trigger方法执行我们通过TransactionHookManager.registerHook()注册的一些hook方法，如果我们要在事务开始前后做一些事情，就可以通过这种方式。</p>
<p>进入tx.begin()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void begin(int timeout, String name) throws TransactionException &#123;</span><br><span class="line">    if (role != GlobalTransactionRole.Launcher) &#123;</span><br><span class="line">        assertXIDNotNull();</span><br><span class="line">        if (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            LOGGER.debug(&quot;Ignore Begin(): just involved in global transaction [&#123;&#125;]&quot;, xid);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    assertXIDNull();</span><br><span class="line">    if (RootContext.getXID() != null) &#123;</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //开启事务并拿到xid</span><br><span class="line">    xid = transactionManager.begin(null, null, name, timeout);</span><br><span class="line">    //设置事务状态</span><br><span class="line">    status = GlobalStatus.Begin;</span><br><span class="line">    //xid跟当前线程做全局绑定</span><br><span class="line">    RootContext.bind(xid);</span><br><span class="line">    if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">        LOGGER.info(&quot;Begin new global transaction [&#123;&#125;]&quot;, xid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>继续到 transactionManager.begin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String begin(String applicationId, String transactionServiceGroup, String name, int timeout)</span><br><span class="line">    throws TransactionException &#123;</span><br><span class="line">    GlobalBeginRequest request = new GlobalBeginRequest();</span><br><span class="line">    request.setTransactionName(name);</span><br><span class="line">    request.setTimeout(timeout);</span><br><span class="line"></span><br><span class="line">    //通知seata-server开启全局事务，并拿到全局事务id(xid)</span><br><span class="line">    GlobalBeginResponse response = (GlobalBeginResponse)syncCall(request);</span><br><span class="line">    if (response.getResultCode() == ResultCode.Failed) &#123;</span><br><span class="line">        throw new TmTransactionException(TransactionExceptionCode.BeginFailed, response.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    return response.getXid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>最后我们就开启了一个全局事务，那么我们的xid是怎么向下游传递的呢，看看对feign的集成是怎么做的？SeataFeignClient.execute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">       //设置xid</span><br><span class="line">	Request modifiedRequest = getModifyRequest(request);</span><br><span class="line">       //调用下游服务</span><br><span class="line">	return this.delegate.execute(modifiedRequest, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Request getModifyRequest(Request request) &#123;</span><br><span class="line"></span><br><span class="line">	String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">	if (StringUtils.isEmpty(xid)) &#123;</span><br><span class="line">		return request;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Collection&lt;String&gt;&gt; headers = new HashMap&lt;&gt;(MAP_SIZE);</span><br><span class="line">       //设置xid到消息头</span><br><span class="line">	headers.putAll(request.headers());</span><br><span class="line"></span><br><span class="line">	List&lt;String&gt; seataXid = new ArrayList&lt;&gt;();</span><br><span class="line">	seataXid.add(xid);</span><br><span class="line">	headers.put(RootContext.KEY_XID, seataXid);</span><br><span class="line"></span><br><span class="line">	return Request.create(request.method(), request.url(), headers, request.body(),</span><br><span class="line">			request.charset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里用SeataFeignClient替换了默认的feignClient，把xid放到了requestHeader里。那么下游又是怎么拿的呢？SeataHandlerInterceptor.preHandle()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      @Override</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		Object handler) &#123;</span><br><span class="line"></span><br><span class="line">	String xid = RootContext.getXID();</span><br><span class="line"></span><br><span class="line">               //从消息头中获取xid</span><br><span class="line">	String rpcXid = request.getHeader(RootContext.KEY_XID);</span><br><span class="line">	if (log.isDebugEnabled()) &#123;</span><br><span class="line">		log.debug(&quot;xid in RootContext &#123;&#125; xid in RpcContext &#123;&#125;&quot;, xid, rpcXid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (xid == null &amp;&amp; rpcXid != null) &#123;</span><br><span class="line">		RootContext.bind(rpcXid);</span><br><span class="line">		if (log.isDebugEnabled()) &#123;</span><br><span class="line">			log.debug(&quot;bind &#123;&#125; to RootContext&quot;, rpcXid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里SeataHandlerInterceptor实现了HandlerInterceptor，springMVC会在Controller方法调用之前拿到所有注册到容器中的拦截器链去执行其preHandle()方法，具体可参考DispatcherServlet.doDispatch()。</p>
<p>好了，到这里就大概把seata的全局事务的开启以及xid的传递捋了一遍，后面会聊聊seata跟hystrix做集成时常见的一些坑</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Vertx实战之如何追踪异步函数调用</title>
    <url>/posts/6a250a7b/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>日常开发中我们经常需要处理各种系统问题，而这些系统问题通常由一些非预期的因素引起（比如非预期的输入，内存不够，网络波动等）。此时就需要知道</p>
<ol>
<li>本次系统问题影响了谁？</li>
<li>如果本次系统问题是因为非预期的输入而导致的，那么这个非预期的输入是什么？</li>
</ol>
<p>上述两点在同步编程里可以通过全局try-catch来实现。但在异步编程里该怎么办呢？</p>
<hr>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的想法是绑定一个唯一id到一次完整的请求调用中（这个完整取决于我们想要监控的范围），无论程序执行到何处，我们总能拿到与请求一一对应的<code>调用上下文</code>的id。</p>
<p>  我将分两种场景进行讨论。一种是同步或基于jut下的线程池类进行异步调用的应用程序（如基于spring5之前的应用程序）。另外一种基于vertx（底层基于netty）的应用程序。</p>
<hr>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><code>vert.x 4</code>、<code>netty 4</code>、<a href="https://github.com/alibaba/transmittable-thread-local"><code>alibaba TransmittableThreadLocal</code></a>、<code>jboss javassist</code>、hotspot类加载&amp;方法调用</p>
<hr>
<h2 id="1-同步or基于jdk的异步"><a href="#1-同步or基于jdk的异步" class="headerlink" title="1. 同步or基于jdk的异步"></a>1. 同步or基于jdk的异步</h2><p><strong>关于这种场景，有以下几种实现：</strong></p>
<ol>
<li><p><strong>程序中的函数调用是完全同步的</strong></p>
<p> 则可通过<code>java.lang.ThreadLocal</code>绑定一个唯一id到当前线程。入口处生成，出口处销毁。<br> 如果我们用的是logback，也可通过 <code>org.slf4j.MDC</code> 来实现这个功能。其内部也是基于ThreadLocal。</p>
</li>
<li><p><strong>程序中函数调用是异步的，异步通过新建<code>java.lang.Thread</code> 的方式实现。</strong></p>
<p> 这里可通过<code>java.lang.InheritableThreadLocal</code> 绑定一个唯一id到当前线程。<code>Thread</code>的构造函数里会自动把通过<code>InheritableThreadLocal</code> 绑定到当前线程的数据拷贝到这个正在创建的<code>Thread</code> 里。所以，只要这个<code>Thread</code> 是在我们<strong>需要监控的区域（当前线程通过</strong><code>InheritableThreadLocal</code><strong>绑定了id后）</strong>创建的，就能实现这个唯一id的跨线程传递。</p>
</li>
<li><p><strong>程序中函数调用是异步的，异步通过<code>java.util.concurrent</code> 下的线程池类实现。</strong></p>
<p> 由于线程池中的线程是可以复用的，所以，如果我们往线程池中丢任务时，有两种情况：</p>
<ol>
<li>线程池创建新的线程来执行该任务（比如线程池中的线程数&lt;coreSize）。这种情况下<code>InheritableThreadLocal</code> 依然是有效的。</li>
<li>线程池把任务分配给了已有线程（比如线程池中的线程数≥coreSize并且待执行任务队列没有填满）。这种情况下<code>InheritableThreadLocal</code> 是无法生效的（线程池中的存活线程会循环拉取等待任务队列中的task去执行，而这个过程是没有<code>InheritableThreadLocal</code> 拷贝的）。所以，这里可以用阿里的<code>[TransmittableThreadLocal](https://github.com/alibaba/transmittable-thread-local)</code> 组件来实现这个唯一id在线程池中的传递（其核心原理是在<code>Runnable</code> 中用一个变量来存储当前线程的ThreadLocal值，当线程执行此Runnable时再拿出来）。</li>
</ol>
</li>
</ol>
<hr>
<h3 id="实现思路总结"><a href="#实现思路总结" class="headerlink" title="实现思路总结"></a>实现思路总结</h3><p>  异步环境下的关键在于如何跨线程传递ThreadLocal的值</p>
<hr>
<h2 id="2-Vertx-中的实现"><a href="#2-Vertx-中的实现" class="headerlink" title="2. Vertx 中的实现"></a>2. Vertx 中的实现</h2><p>  <code>vertx</code>是一个类似于<code>spring</code>系列的用于构建分布式微服务的框架。基于<code>vertx</code>构建的应用程序最大的特点是<strong>无阻塞</strong>&amp;<strong>全异步。</strong></p>
<p>  vertx里的异步主要分两种。一种是在eventbus上传递消息的异步。另一种是基于netty的io操作异步</p>
<h3 id="1-eventbus上异步传递消息"><a href="#1-eventbus上异步传递消息" class="headerlink" title="1. eventbus上异步传递消息"></a>1. eventbus上异步传递消息</h3><p>   先来看一个简单的示例程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ADDRESS_1 = <span class="string">&quot;address1&quot;</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_1 = <span class="string">&quot;message1&quot;</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> String REPLY_MESSAGE_1 = <span class="string">&quot;replyMessage1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMsgByEventbus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化一个具有默认设置的vertx实例</span></span><br><span class="line">       Vertx vertx = Vertx.vertx();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//注册一个handler/consumer到eventbus</span></span><br><span class="line">       vertx.eventBus().consumer(ADDRESS_1, event -&gt; &#123;</span><br><span class="line">           log.info(<span class="string">&quot;receive msg:&#123;&#125;&quot;</span>, event.body());</span><br><span class="line">           event.reply(REPLY_MESSAGE_1);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过eventbus发送消息给刚注册的handler</span></span><br><span class="line">       vertx.eventBus().request(ADDRESS_1, MESSAGE_1, reply -&gt; &#123;</span><br><span class="line">           log.info(<span class="string">&quot;receive replied msg:&#123;&#125;&quot;</span>, reply.result().body());</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面是程序执行的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[vert.x-eventloop-thread-<span class="number">0</span>] - receive msg:message1</span><br><span class="line">[vert.x-eventloop-thread-<span class="number">0</span>] - receive replied msg:replyMessage1</span><br></pre></td></tr></table></figure>

<p>可以看到发起调用的是主线程，处理调用跟处理回调的是线程<code>vert.x-eventloop-thread-0</code>。</p>
<p>那么，这个异步是如何实现的呢？显然，异步最明显的体现就是最后发送消息这里。所以我们就从<code>Eventbus#request</code> 逐步深入。</p>
<p><strong>大概流程是这样的：</strong></p>
<ol>
<li>从<code>eventbus</code>中根据我们传入的<code>address</code>拿到所有注册到这个地址上的handler。</li>
<li>将对应<code>handler</code>对传入消息的处理包装成一个<code>runnable</code>丢进一个<code>queue</code></li>
<li><code>eventLoop Thread</code>从这个<code>queue</code>中抓取<code>task</code>执行</li>
</ol>
<p><strong>关键代码片段如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与本主题无关的只展示调用链路供大家参考</span></span><br><span class="line"><span class="comment">//Eventbus#request</span></span><br><span class="line"><span class="comment">//  EventbusImpl#request</span></span><br><span class="line"><span class="comment">//    EventbusImpl#sendOrPubInternal</span></span><br><span class="line"><span class="comment">//      EventbusImpl#sendOrPubInternal</span></span><br><span class="line"><span class="comment">//        EventbusImpl#OutboundDeliveryContext</span></span><br><span class="line"><span class="comment">//          EventbusImpl#sendOrPub</span></span><br><span class="line"><span class="comment">//            EventbusImpl#sendLocally</span></span><br><span class="line"><span class="comment">//              EventbusImpl#deliverMessageLocally</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ReplyException <span class="title">deliverMessageLocally</span><span class="params">(MessageImpl msg)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">//1.找出跟msg.address()的handlerHolder</span></span><br><span class="line">	  ConcurrentCyclicSequence&lt;HandlerHolder&gt; handlers = handlerMap.get(msg.address());</span><br><span class="line">	  <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">for</span> (HandlerHolder holder: handlers) &#123;</span><br><span class="line">		  <span class="comment">//2.依次调用这些handler的receive方法</span></span><br><span class="line">	      holder.handler.receive(msg.copyBeforeReceive());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(MessageImpl msg)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">//3.匿名异步任务进队列</span></span><br><span class="line">	  context.nettyEventLoop().execute(() -&gt; &#123;</span><br><span class="line">	     doReceive(msg);</span><br><span class="line">	  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SingleThreadEventExecutor#execute</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//比较当前线程是否是eventLoop线程，是则返回true</span></span><br><span class="line">	<span class="comment">//由于我们在main里调用的eventbus#request,所以这里是false</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 添加到queue中，后面执行任务的线程会调用该queue的poll方法</span></span><br><span class="line">    addTask(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">		<span class="comment">//如果当前eventLoop对象的thread为空则创建一个Thread绑定到当前eventLoop</span></span><br><span class="line">        startThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eventLoop中运行的thread通过这个方法从上面说的queue中拿task执行</span></span><br><span class="line"><span class="comment">//外层会循环执行该runAllTasks，直到Eventloop#shutdownGracefully被执行</span></span><br><span class="line"><span class="comment">//参考NioEventLoop#run</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">      Runnable task = pollTask();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		  <span class="comment">//5.执行task</span></span><br><span class="line">          safeExecute(task);</span><br><span class="line"></span><br><span class="line">          runTasks ++;</span><br><span class="line">					</span><br><span class="line">		  <span class="comment">//如果队列中还有task，则继续执行</span></span><br><span class="line">          task = pollTask();</span><br><span class="line">          <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">              lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">pollTaskFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Runnable task = taskQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (task != WAKEUP_TASK) &#123;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//safeExecute会去执行第3步中的匿名任务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doReceive</span><span class="params">(Message&lt;T&gt; message)</span> </span>&#123;</span><br><span class="line">		Handler&lt;Message&lt;T&gt;&gt; theHandler = handler;</span><br><span class="line">		</span><br><span class="line">		deliver(theHandler, message);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MessageConsumerImpl#deliver</span></span><br><span class="line"><span class="comment">//  MessageConsumerImpl#dispatch</span></span><br><span class="line"><span class="comment">//    AbstractContext#dispatch</span></span><br><span class="line"><span class="comment">//      InboundDeliveryContext#dispatch   ++ 上一步的匿名Runnable会调用 </span></span><br><span class="line"><span class="comment">//        InboundDeliveryContext#next</span></span><br><span class="line"><span class="comment">//          MessageConsumerImpl#dispatch</span></span><br><span class="line"><span class="comment">//            DuplicatedContext#emit</span></span><br><span class="line"><span class="comment">//              EventLoopContext#emit</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(AbstractContext ctx, T argument, Handler&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">//6.执行handler/task中的事件处理</span></span><br><span class="line">	  <span class="comment">//这个task就是我们之前通过Eventbus#consumer注册进来的</span></span><br><span class="line">      task.handle(argument);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      reportException(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ctx.endDispatch(prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我删减了一些不重要的部分，以便更易于理解。</p>
<p>通过上面的代码片段我们可以发现，第3步的<code>SingleThreadEventExecutor#execute</code>往队列里push任务似乎是解决问题（跨线程传递唯一id）的关键。所以，如果我们能够<strong>在这个task进入<code>queue</code>之前往这个task中塞上当前线程的<code>ThreadLocal</code>值，待到这个<code>task</code>的<code>run</code>方法被执行时再把这个<code>ThreadLocal</code>值拿出来塞到当前线程（执行这个<code>task</code>的线程）的<code>ThreadLocal</code>中</strong>，问题就解决了。</p>
<p>显然，我们需要修改这些类的代码。那么，怎么实现这个功能呢？</p>
<p><code>java.lang.instrument</code> 提供了一系列运行时替换class字节码的技术。而<a href="https://github.com/jboss-javassist/javassist">jboss Javaassist</a> 则提供了一些列修改字节码的接口。所以我们只需要结合这两项技术再通过javaagent指令即可达成我们的目的。</p>
<p>修改字节码的实现可参考<a href="https://github.com/scientificCommunity/blog-sample/blob/main/vertx4-transformer/src/main/java/org/baichuan/example/vertx/transformer/VertxFutureTransformer.java">这里</a>。</p>
<hr>
<h4 id="关于类加载"><a href="#关于类加载" class="headerlink" title="关于类加载"></a>关于类加载</h4><p>由于<strong>参与修改</strong>的<strong>所有类</strong>都是由**<code>appClassLoader</code><strong>加载的，所以不会出现什么问题。但是，如果我们要按照上述设计对</strong>jdk自带(jre/lib)的一些类<strong>进行修改呢？比如说实现<code>ThreadLocal</code>在<code>ThreadPoolExecutor#execute</code>中的传递，思路似乎没多大区别，无非就是对传入<code>ThreadPoolExecutor#execute</code>中的<code>Runnable</code>做一层包装（设该包装类为</strong>类A<strong>）。然后当我们运行是却会发现每次执行<code>execute</code>方法时都会得到一个<code>NoClassDefFoundException</code>，无法找到</strong>类A**。</p>
<p>这是为什么呢？明明<strong>类A</strong>对应的<code>class</code>文件是<strong>存在的</strong>(build目录下)，但虚拟机为什么在执行<code>execute</code>方法时找不到它呢？</p>
<p>这是因为<code>ThreadPoolExecutor</code>这个类是由<code>BootStrapClassLoader</code>加载的，而正常情况下类A并不处于<code>BootStrapClassLoader</code>的查找范围之中，所以就引发了这个异常。概览如下：</p>
<ul>
<li>在虚拟机第一次执行到<code>execute</code>方法中我们修改过的代码时，此时类A在此处仅仅是一个符号引用，这时必然会请求虚拟机去<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/constantPool.cpp#l180">解析</a>这个符号引用。这里会去根据<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/constantPool.cpp#l212">加载ThreadPoolExecutor的类加载器</a>(<code>BootStrapClassLoader</code>)以及<strong>类A</strong>的类名在内存中<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/classfile/systemDictionary.cpp#l616">全局查找这个类</a>，查找不到则会尝试<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/classfile/systemDictionary.cpp#l1289">加载这个类</a>，如果这两个过程都找不到对应的类，就会抛出上述异常。</li>
</ul>
<p>像alibaba的<a href="https://github.com/alibaba/transmittable-thread-local"><code>TransmittableThreadLocal</code></a> 是需要修改rt.jar中的类的(比如<code>ThreadPoolExecutor</code>)，这些核心类都是由BootstrapClassloader加载的。但是我们引进来的<a href="https://github.com/alibaba/transmittable-thread-local"><code>TransmittableThreadLocal</code></a> 默认由AppClassLoader加载，这势必会导致在重新加载被修改的由class时抛出NoClassDefFoundException。所以<a href="https://github.com/alibaba/transmittable-thread-local"><code>TransmittableThreadLocal</code></a> 中<strong>参与核心类库修改的类必须要被添加到bootClassPath中</strong>(由<code>BootstrapClassLoader</code>加载)。</p>
<h3 id="2-基于netty的异步io操作"><a href="#2-基于netty的异步io操作" class="headerlink" title="2. 基于netty的异步io操作"></a>2. 基于netty的异步io操作</h3><p>vertx的io操作基于netty，netty的io多路复用基于java nio，nio只能说是非阻塞式io。但是netty提供给上层应用程序的io操作确实异步的。netty会不停的轮询就绪的io事件，然后把vertx感兴趣的事件包装好通知到vertx（比如有数据可读的时候），最后vertx再通知到我们的业务层。</p>
<p>其实这里的实现思路是一样的，就不赘述了。简单点就是在往vertx中塞回调时对这个回调进行上述包装即可。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要探讨了如何在基于vertx的异步环境中追踪一次完整的函数调用，以及实现过程中可能会碰到的问题。</p>
<p>上述内容的源码可在<a href="https://github.com/scientificCommunity/blog-sample">我的github</a>上找到。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>jvm</tag>
        <tag>实战</tag>
        <tag>Vertx</tag>
      </tags>
  </entry>
  <entry>
    <title>seata源码分析之如何控制下游服务的提交与回滚</title>
    <url>/posts/940a39da/</url>
    <content><![CDATA[<p>概览</p>
<h3 id="seata-client跟维持了一个连接，监听server端的消息，根据接到的消息判断是提交还是回滚。"><a href="#seata-client跟维持了一个连接，监听server端的消息，根据接到的消息判断是提交还是回滚。" class="headerlink" title="seata client跟维持了一个连接，监听server端的消息，根据接到的消息判断是提交还是回滚。"></a>seata client跟维持了一个连接，监听server端的消息，根据接到的消息判断是提交还是回滚。</h3><p><strong>客户端建立流程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GlobalTransactionScanner.afterPropertiesSet()</span><br><span class="line">   GlobalTransactionScanner.initClient()</span><br><span class="line">      TMClient.init</span><br><span class="line">        TmRpcClient.getInstance</span><br><span class="line">             new TmRpcClient</span><br><span class="line">                new RpcClientBootstrap</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>RpcClientBootstrap内部包装了netty的Bootstrap，其中会向Bootstrap绑定一个ClientHandler用来处理seata server返回来的消息</p>
<p>，最终通过Bootstrap建立与server端的连接。</p>
<p>接下来就是核心处理逻辑了，先看看类图</p>
<p><img src="https://img-blog.csdnimg.cn/20200712110624216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjaWVudGlmaWNDb21tdW5pdHk=,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200712110624216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjaWVudGlmaWNDb21tdW5pdHk=,size_16,color_FFFFFF,t_70"></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里ClientHandler实现了ChannelInboundHandler的channelRead()方法，netty在接收到消息（读事件）后，最终会调用channelRead，并传入读到的消息，具体细节可参考netty源码，所以，我们先来看下这个方法的执行流程</p>
<p>ClientHandler.channelRead</p>
<p>AbstractHandler.channelRead</p>
<p>ClientHandler.dispatch</p>
<p>RmMessageListener.onMessage</p>
<p>RmMessageListener会根据消息反序列化后的类型决定事物的提交与回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onMessage(RpcMessage request, String serverAddress) &#123;</span><br><span class="line">    Object msg = request.getBody();</span><br><span class="line">    if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">        LOGGER.info(&quot;onMessage:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg instanceof BranchCommitRequest) &#123;</span><br><span class="line">        handleBranchCommit(request, serverAddress, (BranchCommitRequest)msg);</span><br><span class="line">    &#125; else if (msg instanceof BranchRollbackRequest) &#123;</span><br><span class="line">        handleBranchRollback(request, serverAddress, (BranchRollbackRequest)msg);</span><br><span class="line">    &#125; else if (msg instanceof UndoLogDeleteRequest) &#123;</span><br><span class="line">        handleUndoLogDelete((UndoLogDeleteRequest) msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里只说一下rollback，上面的rollback最终会到达AbstracRMHandler.doBranchRollback()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doBranchRollback(BranchRollbackRequest request, BranchRollbackResponse response)</span><br><span class="line">        throws TransactionException &#123;</span><br><span class="line">        String xid = request.getXid();</span><br><span class="line">        long branchId = request.getBranchId();</span><br><span class="line">        String resourceId = request.getResourceId();</span><br><span class="line">        String applicationData = request.getApplicationData();</span><br><span class="line">        if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(&quot;Branch Rollbacking: &quot; + xid + &quot; &quot; + branchId + &quot; &quot; + resourceId);</span><br><span class="line">        &#125;</span><br><span class="line">        BranchStatus status = getResourceManager().branchRollback(request.getBranchType(), xid, branchId, resourceId,</span><br><span class="line">            applicationData);</span><br><span class="line">        response.setXid(xid);</span><br><span class="line">        response.setBranchId(branchId);</span><br><span class="line">        response.setBranchStatus(status);</span><br><span class="line">        if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(&quot;Branch Rollbacked result: &quot; + status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里会从server发来的消息中获取xid等信息，然后调用AbstractUndoLogManager.undo方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void undo(DataSourceProxy dataSourceProxy, String xid, long branchId) throws TransactionException &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        PreparedStatement selectPST = null;</span><br><span class="line">        boolean originalAutoCommit = true;</span><br><span class="line"></span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn = dataSourceProxy.getPlainConnection();</span><br><span class="line"></span><br><span class="line">                // The entire undo process should run in a local transaction.</span><br><span class="line">                if (originalAutoCommit = conn.getAutoCommit()) &#123;</span><br><span class="line">                    conn.setAutoCommit(false);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Find UNDO LOG</span><br><span class="line">                selectPST = conn.prepareStatement(SELECT_UNDO_LOG_SQL);</span><br><span class="line">                selectPST.setLong(1, branchId);</span><br><span class="line">                selectPST.setString(2, xid);</span><br><span class="line"></span><br><span class="line">                //拿到undo log</span><br><span class="line">                rs = selectPST.executeQuery();</span><br><span class="line"></span><br><span class="line">                boolean exists = false;</span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    exists = true;</span><br><span class="line"></span><br><span class="line">                    // It is possible that the server repeatedly sends a rollback request to roll back</span><br><span class="line">                    // the same branch transaction to multiple processes,</span><br><span class="line">                    // ensuring that only the undo_log in the normal state is processed.</span><br><span class="line">                    int state = rs.getInt(ClientTableColumnsName.UNDO_LOG_LOG_STATUS);</span><br><span class="line">                    if (!canUndo(state)) &#123;</span><br><span class="line">                        if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                            LOGGER.info(&quot;xid &#123;&#125; branch &#123;&#125;, ignore &#123;&#125; undo_log&quot;, xid, branchId, state);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String contextString = rs.getString(ClientTableColumnsName.UNDO_LOG_CONTEXT);</span><br><span class="line">                    Map&lt;String, String&gt; context = parseContext(contextString);</span><br><span class="line">                    byte[] rollbackInfo = getRollbackInfo(rs);</span><br><span class="line"></span><br><span class="line">                    String serializer = context == null ? null : context.get(UndoLogConstants.SERIALIZER_KEY);</span><br><span class="line">                    UndoLogParser parser = serializer == null ? UndoLogParserFactory.getInstance()</span><br><span class="line">                        : UndoLogParserFactory.getInstance(serializer);</span><br><span class="line">                    BranchUndoLog branchUndoLog = parser.decode(rollbackInfo);</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        // put serializer name to local</span><br><span class="line">                        setCurrentSerializer(parser.getName());</span><br><span class="line">                        List&lt;SQLUndoLog&gt; sqlUndoLogs = branchUndoLog.getSqlUndoLogs();</span><br><span class="line">                        if (sqlUndoLogs.size() &gt; 1) &#123;</span><br><span class="line">                            Collections.reverse(sqlUndoLogs);</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (SQLUndoLog sqlUndoLog : sqlUndoLogs) &#123;</span><br><span class="line">                            TableMeta tableMeta = TableMetaCacheFactory.getTableMetaCache(dataSourceProxy.getDbType()).getTableMeta(</span><br><span class="line">                                conn, sqlUndoLog.getTableName(), dataSourceProxy.getResourceId());</span><br><span class="line">                            sqlUndoLog.setTableMeta(tableMeta);</span><br><span class="line">                            AbstractUndoExecutor undoExecutor = UndoExecutorFactory.getUndoExecutor(</span><br><span class="line">                                dataSourceProxy.getDbType(), sqlUndoLog);</span><br><span class="line"></span><br><span class="line">                            //处理delete跟update的回滚</span><br><span class="line">                            undoExecutor.executeOn(conn);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        // remove serializer name</span><br><span class="line">                        removeCurrentSerializer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If undo_log exists, it means that the branch transaction has completed the first phase,</span><br><span class="line">                // we can directly roll back and clean the undo_log</span><br><span class="line">                // Otherwise, it indicates that there is an exception in the branch transaction,</span><br><span class="line">                // causing undo_log not to be written to the database.</span><br><span class="line">                // For example, the business processing timeout, the global transaction is the initiator rolls back.</span><br><span class="line">                // To ensure data consistency, we can insert an undo_log with GlobalFinished state</span><br><span class="line">                // to prevent the local transaction of the first phase of other programs from being correctly submitted.</span><br><span class="line">                // See https://github.com/seata/seata/issues/489</span><br><span class="line"></span><br><span class="line">                if (exists) &#123;</span><br><span class="line">                    deleteUndoLog(xid, branchId, conn);</span><br><span class="line">                    conn.commit();</span><br><span class="line">                    if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                        LOGGER.info(&quot;xid &#123;&#125; branch &#123;&#125;, undo_log deleted with &#123;&#125;&quot;, xid, branchId,</span><br><span class="line">                            State.GlobalFinished.name());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //执行insert的回滚</span><br><span class="line">                    insertUndoLogWithGlobalFinished(xid, branchId, UndoLogParserFactory.getInstance(), conn);</span><br><span class="line">                    conn.commit();</span><br><span class="line">                    if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                        LOGGER.info(&quot;xid &#123;&#125; branch &#123;&#125;, undo_log added with &#123;&#125;&quot;, xid, branchId,</span><br><span class="line">                            State.GlobalFinished.name());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (SQLIntegrityConstraintViolationException e) &#123;</span><br><span class="line">                // Possible undo_log has been inserted into the database by other processes, retrying rollback undo_log</span><br><span class="line">                if (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                    LOGGER.info(&quot;xid &#123;&#125; branch &#123;&#125;, undo_log inserted, retry rollback&quot;, xid, branchId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                if (conn != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        conn.rollback();</span><br><span class="line">                    &#125; catch (SQLException rollbackEx) &#123;</span><br><span class="line">                        LOGGER.warn(&quot;Failed to close JDBC resource while undo ... &quot;, rollbackEx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw new BranchTransactionException(BranchRollbackFailed_Retriable, String</span><br><span class="line">                    .format(&quot;Branch session rollback failed and try again later xid = %s branchId = %s %s&quot;, xid,</span><br><span class="line">                        branchId, e.getMessage()), e);</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (rs != null) &#123;</span><br><span class="line">                        rs.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (selectPST != null) &#123;</span><br><span class="line">                        selectPST.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (conn != null) &#123;</span><br><span class="line">                        if (originalAutoCommit) &#123;</span><br><span class="line">                            conn.setAutoCommit(true);</span><br><span class="line">                        &#125;</span><br><span class="line">                        conn.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (SQLException closeEx) &#123;</span><br><span class="line">                    LOGGER.warn(&quot;Failed to close JDBC resource while undo ... &quot;, closeEx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==">data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==</a></p>
<p>这里做的事情就是拿到事务执行前后的数据镜像，然后解析成rollback sql去进行数据补偿</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当全局回滚发生时，server会发送一个回滚消息到client端，client接到回滚通知后，通过xid跟branchid找到对应的undolog，获取到事务执行前后的数据镜像，解析成反向sql进行补偿</p>
<p>同时，我们发现，下游服务不会主动的去rollback全局事务，所以，如果下游异常，但是上游的transcationInterceptor没有感知到这个异常，就不会触发全局回滚</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈之容器内访问宿主机docker命令</title>
    <url>/posts/47873/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>docker</code>在被安装时默认会在<code>/var/lib/docker.sock</code>创建<code>unix domain socket</code>。<code>docker daemon</code>会通过它来监听<a href="https://docs.docker.com/engine/api/">Docker Engine API</a> 请求。而<code>docker</code>命令本质上是在<code>/bin/docker</code>里包装了这些请求交互的细节(猜想，有研究过的朋友可以分享一下🤝)。所以我们只需要将这两个文件挂载到容器中即可。</p>
<p><em>如果只挂载<code>/var/lib/docker.sock</code>，我们查看容器列表(<code>docker ps</code>)就需要这样操作：</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s --unix-socket /var/run/docker.sock http://dummy/containers/json</span><br></pre></td></tr></table></figure>

<p><strong>总的来说：</strong></p>
<ol>
<li><code>/var/lib/docker.sock</code>保证能跟<code>docker daemon</code>通信</li>
<li><code>/bin/docker</code>隐藏通信细节<h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name &lt;yourContainerName&gt;</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">	-v /bin/docker:/bin/docker \</span><br></pre></td></tr></table></figure>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1></li>
<li>如果<code>docker</code>容器内需要访问宿主机<code>docker</code>命令的用户不是<code>root</code>用户或者不属于<code>docker</code>组的用户，则还需执行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li>
<li>如果容器基于<code>Alpine Linux</code>，基于 <code>glibc</code> 构建的<code>/bin/docker</code>是无法执行的。所以还需要执行如下操作： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub</span><br><span class="line"></span><br><span class="line">wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.34-r0/glibc-2.34-r0.apk</span><br><span class="line"></span><br><span class="line">apk add glibc-2.34-r0.apk</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><a href="https://blog.csdn.net/scientificCommunity/article/details/120386344">杂谈之非root用户运行docker命令</a><br><a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option">Daemon socket option</a><br><a href="https://github.com/sgerrand/alpine-pkg-glibc">alpine-pkg-glibc</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈之树莓派挂载硬盘</title>
    <url>/posts/4224/</url>
    <content><![CDATA[<h2 id="挂载步骤"><a href="#挂载步骤" class="headerlink" title="挂载步骤"></a>挂载步骤</h2><ol>
<li><p><code>fdisk -l</code> 找到新接入的硬盘，通常是<code>/dev/sda</code>+一个序号(第一块硬盘则直接是<code>/dev/sda</code>)</p>
</li>
<li><p><code>mkfs.ext4 /dev/sda</code> 硬盘文件系统格式化为<code>ext4</code></p>
</li>
<li><p><code>sudo mount /dev/sda  /home/pi/xxx</code>  将硬盘挂载到<code>/home/pi/xxx</code>目录下。</p>
</li>
<li><p><code>df -h</code>  即可看到新挂载的硬盘对应的目录信息</p>
</li>
<li><p>配置开机自动挂载(如果不配置，系统重启后上述配置会失效)</p>
<ol>
<li><p><code>vim /etc/fstab</code></p>
</li>
<li><p>添加一行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sda  /home/pi/xxx      defaults  0 0</span><br></pre></td></tr></table></figure></li>
<li><p><code>reboot</code></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试之kotlin mockk用法浅析</title>
    <url>/posts/a1887a80/</url>
    <content><![CDATA[<h2 id="本例用到的类定义"><a href="#本例用到的类定义" class="headerlink" title="本例用到的类定义"></a>本例用到的类定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImplA</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;input is:&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;doSomething2,input:&#123;&#125;&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>文中会出现一个定义：<code>可mock状态</code></p>
<p>通过mockk&lt;&gt;(),mockkObject(),spyk()返回的对象就处于mock状态。只有处于这个状态的对象才能通过every对对象的行为进行Mock</p>
<h2 id="mockk"><a href="#mockk" class="headerlink" title="mockk()"></a>mockk<T>()</h2><ul>
<li>mock类T并返回该类的mock对象</li>
</ul>
<p>这个方法返回T的实例，该实例所有函数都为<code>待mock状态</code>，这些待mock状态的函数都==不能直接调用==，需要结合every{}mock对应方法后才能调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回ServiceImplA一个mock对象</span></span><br><span class="line">val mockk = mockk&lt;ServiceImplA&gt;()</span><br><span class="line"><span class="comment">//mock指定方法</span></span><br><span class="line">every &#123; mockk.doSomething1(any()) &#125; returns Unit</span><br><span class="line"><span class="comment">//调用被mock的方法</span></span><br><span class="line">mockk.doSomething1(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">//该方法未通过every进行mock，会报错</span></span><br><span class="line">mockk.doSomething2(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="mockkObject"><a href="#mockkObject" class="headerlink" title="mockkObject()"></a>mockkObject()</h2><ul>
<li>将指定对象转为可mock状态</li>
</ul>
<p>与mockk&lt;&gt;()的区别是返回的mock对象，允许mock行为跟真实行为并存，如果不主动mock，则执行真实行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val serviceImplA = ServiceImplA()</span><br><span class="line">mockkObject(serviceImplA)</span><br><span class="line">every &#123; serviceImplA.doSomething1(any()) &#125; returns Unit</span><br><span class="line"><span class="comment">//调用被mock方法</span></span><br><span class="line">serviceImplA.doSomething1(<span class="string">&quot;sfas&quot;</span>)</span><br><span class="line"><span class="comment">//调用真实方法</span></span><br><span class="line">serviceImplA.doSomething2(<span class="string">&quot;sfas&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="spyk-amp-spyk-T-obj"><a href="#spyk-amp-spyk-T-obj" class="headerlink" title="spyk() &amp; spyk(T obj)"></a>spyk<T>() &amp; spyk(T obj)</h2><ul>
<li>返回T的spyk对象或者obj的spyk对象</li>
<li>与mockk&lt;&gt;()的区别是，spyk&lt;&gt;()返回的对象是允许<strong>真实行为跟mock行为共存的</strong>，其表现跟mockkObject()相似<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回ServiceImplA的一个spyk对象</span></span><br><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line">every &#123; spyk.doSomething1(any()) &#125; returns Unit</span><br><span class="line"><span class="comment">//调用mock方法</span></span><br><span class="line">spyk.doSomething1(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment">//调用真实方法</span></span><br><span class="line">spyk.doSomething2(<span class="string">&quot;999&quot;</span>)</span><br><span class="line"></span><br><span class="line">val serviceImplA = ServiceImplA()</span><br><span class="line"><span class="comment">//返回serviceImplA对象被spyk后的对象，原对象不会改变</span></span><br><span class="line">val spyk1 = spyk(serviceImplA)</span><br><span class="line"><span class="comment">//serviceImplA不是可mock状态，这里会报错</span></span><br><span class="line"><span class="comment">//every &#123; serviceImplA.doSomething1(any()) &#125; returns Unit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mock</span></span><br><span class="line">every &#123; spyk1.doSomething1(any()) &#125; returns Unit</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">spyk1.doSomething1(<span class="string">&quot;999&quot;</span>)</span><br><span class="line">spyk1.doSomething2(<span class="string">&quot;999&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="every-…-…"><a href="#every-…-…" class="headerlink" title="every{…} …"></a>every{…} …</h2></li>
<li>定义mock行为</li>
</ul>
<h3 id="returns"><a href="#returns" class="headerlink" title="returns"></a>returns</h3><p>作用是定制mock行为的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line"><span class="comment">//mock doSomething2,无论什么输入都返回111</span></span><br><span class="line">every &#123; spyk.doSomething2(any()) &#125; returns <span class="string">&quot;111&quot;</span></span><br><span class="line"></span><br><span class="line">val input = <span class="string">&quot;222&quot;</span></span><br><span class="line"><span class="comment">//这里拿到的应该是111</span></span><br><span class="line">val mockkResult = spyk.doSomething2(input)</span><br><span class="line">println(<span class="string">&quot;mockk行为结果:$mockkResult&quot;</span>)</span><br><span class="line"></span><br><span class="line">val real = ServiceImplA()</span><br><span class="line"><span class="comment">//这里拿到的应该是222</span></span><br><span class="line">val realResult = real.doSomething2(input)</span><br><span class="line">println(<span class="string">&quot;mockk行为结果:$realResult&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p>有时候我们可能需要在mock行为里做一些运算而不仅仅只是定制一个结果，这个时候就需要answers</p>
<h3 id="answers"><a href="#answers" class="headerlink" title="answers"></a>answers</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val input = <span class="string">&quot;222&quot;</span></span><br><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line"><span class="comment">//定制mock行为</span></span><br><span class="line">every &#123; spyk.doSomething2(any()) &#125; answers &#123;</span><br><span class="line">    <span class="comment">//something will happen</span></span><br><span class="line">    println(<span class="string">&quot;定制mock行为&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到真实函数信息</span></span><br><span class="line">    val originalMethod = invocation.originalCall</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用真实行为并拿到响应结果</span></span><br><span class="line">    val originalResult = callOriginal()</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    val originalResult1 = originalMethod.invoke()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个固定结果</span></span><br><span class="line">    <span class="string">&quot;mock result&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用会执行answers里代码</span></span><br><span class="line">spyk.doSomething2(input)</span><br><span class="line"></span><br><span class="line">every &#123; spyk.doSomething2(any()) &#125; propertyType String::<span class="class"><span class="keyword">class</span> <span class="title">answers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到第一个输入参数</span></span><br><span class="line">    val firstArg = firstArg&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;输入：$firstArg&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;这里是mock后的行为&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制方法返回</span></span><br><span class="line">    <span class="string">&quot;mock响应$firstArg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">spyk.doSomething2(input)</span><br></pre></td></tr></table></figure>
<h3 id="andthen"><a href="#andthen" class="headerlink" title="andthen"></a>andthen</h3><ul>
<li>这个一般可以结合junit的@RepeatTest或者@ParameterizedTest+@ValueSource/@EnumSource一起使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val input = <span class="string">&quot;222&quot;</span></span><br><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line">every &#123; spyk.doSomething2(any()) &#125; propertyType String::<span class="class"><span class="keyword">class</span> <span class="title">answers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到第一个输入参数</span></span><br><span class="line">    val firstArg = firstArg&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;第一次执行，输入：$firstArg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制方法返回</span></span><br><span class="line">    <span class="string">&quot;第一次执行mock响应$firstArg&quot;</span></span><br><span class="line">&#125; andThen &#123;</span><br><span class="line">    <span class="comment">//拿到输入参数</span></span><br><span class="line">    val firstArg = firstArg&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;第二次执行，输入：$firstArg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制方法返回</span></span><br><span class="line">    <span class="string">&quot;第二次执行mock响应$firstArg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">spyk.doSomething2(input)</span><br><span class="line">spyk.doSomething2(input + input)</span><br><span class="line"></span><br><span class="line"><span class="comment">//次数不会重制，会定位到最后一个mock行为</span></span><br><span class="line">spyk.doSomething2(input)</span><br></pre></td></tr></table></figure>
<h3 id="andthenThrow"><a href="#andthenThrow" class="headerlink" title="andthenThrow"></a>andthenThrow</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val input1 = <span class="string">&quot;222&quot;</span></span><br><span class="line">val input2 = <span class="string">&quot;222111&quot;</span></span><br><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line">every &#123; spyk.doSomething3(any(), any()) &#125; propertyType String::<span class="class"><span class="keyword">class</span> <span class="title">answers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到第一个输入参数</span></span><br><span class="line">    val firstArg = firstArg&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;第一次执行，输入：$firstArg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制方法返回</span></span><br><span class="line">    <span class="string">&quot;第一次执行mock响应$firstArg&quot;</span></span><br><span class="line">&#125; andThen &#123;</span><br><span class="line">    <span class="comment">//拿到输入参数</span></span><br><span class="line">    val firstArg = firstArg&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;第二次执行，输入：$firstArg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制方法返回</span></span><br><span class="line">    <span class="string">&quot;第二次执行mock响应$firstArg&quot;</span></span><br><span class="line">&#125; andThenThrows (RuntimeException())</span><br><span class="line">spyk.doSomething3(input1, input2)</span><br><span class="line">spyk.doSomething3(input1 + input1, input2 + input2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三次抛出RuntimeException</span></span><br><span class="line">spyk.doSomething3(input1, input2)</span><br></pre></td></tr></table></figure>
<h3 id="AndThenAnswer"><a href="#AndThenAnswer" class="headerlink" title="AndThenAnswer"></a>AndThenAnswer</h3></li>
<li>可以添加Answer接口的实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val spyk = spyk&lt;ServiceImplA&gt;()</span><br><span class="line"><span class="comment">//定义函数mock行为</span></span><br><span class="line">val functionAnswer = FunctionAnswer &#123;</span><br><span class="line">    println(<span class="string">&quot;functionAnswer&quot;</span>)</span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义异常mock行为，返回一个运行时异常</span></span><br><span class="line">val throwingAnswer = ThrowingAnswer(RuntimeException())</span><br><span class="line"><span class="comment">//定义多个行为处理集合，按添加顺序触发</span></span><br><span class="line">val manyAnswersAnswer = ManyAnswersAnswer(listOf(functionAnswer, throwingAnswer))</span><br><span class="line"><span class="comment">//mock</span></span><br><span class="line">every &#123; spyk.doSomething2(any()) &#125; returns <span class="string">&quot;&quot;</span> andThenAnswer (functionAnswer</span><br><span class="line">        ) andThenAnswer (throwingAnswer</span><br><span class="line">        ) andThenAnswer (manyAnswersAnswer</span><br><span class="line">        <span class="comment">//构造了两个ConstantAnswer组成一个ManyAnswersAnswer对象</span></span><br><span class="line">        <span class="comment">//listOf里输入的每个元素会最终赋值到ConstantAnswer的answer方法调用上</span></span><br><span class="line">        <span class="comment">//如果这里传入的是字符串，则代表这个answer就仅仅是返回这个字符串</span></span><br><span class="line">        <span class="comment">//这里的泛型对应里spyk.doSomething2()的返回参数类型</span></span><br><span class="line">        ) andThenMany (listOf(<span class="string">&quot;functionAnswer&quot;</span>, <span class="string">&quot;throwingAnswer&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次执行进入到returns &quot;&quot;</span></span><br><span class="line">spyk.doSomething2(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//进入functionAnswer</span></span><br><span class="line">spyk.doSomething2(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//第三次进入throwingAnswer抛出运行时异常</span></span><br><span class="line">    spyk.doSomething2(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: RuntimeException) &#123;</span><br><span class="line">    println(<span class="string">&quot;第三次执行抛出运行时异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入manyAnswersAnswer中的functionAnswer</span></span><br><span class="line">spyk.doSomething2(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//进入manyAnswersAnswer中的throwingAnswer</span></span><br><span class="line">    spyk.doSomething2(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: RuntimeException) &#123;</span><br><span class="line">    println(<span class="string">&quot;第5次执行抛出运行时异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将返回functionAnswer</span></span><br><span class="line">println(<span class="string">&quot;第6此调用返回：$&#123;spyk.doSomething2(&quot;</span><span class="number">6</span><span class="string">&quot;)&#125;&quot;</span>)</span><br><span class="line">spyk.doSomething2(<span class="string">&quot;7&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>浅析</tag>
        <tag>unit test</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑日记之Gradle自定义JacocoReport跟Test task</title>
    <url>/posts/60737/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近新写了一个项目，为了更好的保证项目输出的质量，引入了单元测试覆盖率统计框架<code>Jacoco</code>。由于gradle官网上的案例只有几个默认的<code>task(test、JacocoTestReport等)</code>的设置，而我希望能够额外为不同的层提供单独的<code>test</code>，也就发生了接下来这些有趣的事儿。</p>
<h1 id="1-为什么JacocoTestReport总是被SKIPPED"><a href="#1-为什么JacocoTestReport总是被SKIPPED" class="headerlink" title="1. 为什么JacocoTestReport总是被SKIPPED"></a>1. 为什么<code>JacocoTestReport</code>总是被SKIPPED</h1><p>首先，我写了一个自定义的test。并且通过将<code>finalizedBy</code>指定为<code>JacocoTestReport</code>来让test执行完毕后自动执行<code>JacocoTestReport</code>。自定义test以及<code>JacocoTestReport</code> 如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义test</span></span><br><span class="line">task serviceTest(<span class="attr">type:</span> Test) &#123;</span><br><span class="line">    useTestNG()</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line"></span><br><span class="line">	finalizedBy jacocoTestReport</span><br><span class="line"></span><br><span class="line">    jacoco &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//指定原始数据文件位置</span></span><br><span class="line">        destinationFile = layout.buildDirectory.file(<span class="string">&quot;jacoco/$&#123;taskName&#125;.exec&quot;</span>).get().asFile</span><br><span class="line">        includes = [<span class="string">&#x27;xxxservice&#x27;</span>]</span><br><span class="line">        excludeClassLoaders = []</span><br><span class="line">        includeNoLocationClasses = <span class="literal">false</span></span><br><span class="line">        sessionId = <span class="string">&quot;&lt;auto-generated value&gt;&quot;</span></span><br><span class="line">        output = JacocoTaskExtension.Output.FILE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jacocoTestReport &#123;</span><br><span class="line">    <span class="comment">// tests are required to run before generating the report</span></span><br><span class="line">    dependsOn serviceTest</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//指定覆盖率统计数据文件。</span></span><br><span class="line">	executionData(layout.buildDirectory.file(<span class="string">&quot;jacoco/$&#123;serviceTest.name&#125;.exec&quot;</span>).get().asFile)</span><br><span class="line"></span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        classDirectories.setFrom(files(classDirectories.files.collect &#123;</span><br><span class="line">            fileTree(<span class="attr">dir:</span> it, <span class="attr">include:</span> [<span class="string">&#x27;xxxservice&#x27;</span>])</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.required = <span class="literal">false</span></span><br><span class="line">        csv.required = <span class="literal">false</span></span><br><span class="line">        html.outputLocation = layout.buildDirectory.dir(<span class="string">&#x27;jacocoReport&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来似乎没啥问题，该做的都做了。但是执行的时候程序却跳过了jacocoTestReport。当时特别纳闷，就去网上提了个<a href="https://stackoverflow.com/questions/69164311/jacocotestreport-always-skipped/69177867#69177867">问题</a>。最后gradle官方的工作人员给了答复，大概意思是<code>executionData</code>对应的文件不存在，在<code>jacocoTestReport</code>里加上<code>onlyIf = &#123;true&#125;</code> 可以保证<code>jacocoTestReport</code>会执行，并且执行最终会报出test.exec文件不存在的错误。ok，有方向了，那就一个一个来分析。</p>
<h1 id="2-task里的onlyIf"><a href="#2-task里的onlyIf" class="headerlink" title="2. task里的onlyIf"></a>2. <code>task</code>里的<code>onlyIf</code></h1><p>事实上，<code>onlyIf</code>决定了<code>task</code>是否被执行。同时，<code>onlyIf</code>可以设置多个规则判断，如果所有的规则判断都返回为<code>true</code>，才会执行<code>task</code>。否则，跳过<code>task</code>。</p>
<h2 id="2-1-SkipOnlyIfTaskExecuter"><a href="#2-1-SkipOnlyIfTaskExecuter" class="headerlink" title="2.1 SkipOnlyIfTaskExecuter"></a>2.1 <code>SkipOnlyIfTaskExecuter</code></h2><p>让我们进入<code>SkipOnlyIfTaskExecuter</code>一探究竟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipOnlyIfTaskExecuter</span> <span class="keyword">implements</span> <span class="title">TaskExecuter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskExecuterResult <span class="title">execute</span><span class="params">(TaskInternal task, TaskStateInternal state, TaskExecutionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> skip = !task.getOnlyIf().isSatisfiedBy(task);</span><br><span class="line">				</span><br><span class="line">		<span class="comment">//跳过task</span></span><br><span class="line">        <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">            <span class="keyword">return</span> TaskExecuterResult.WITHOUT_OUTPUTS;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">		<span class="comment">//执行task</span></span><br><span class="line">        <span class="keyword">return</span> executer.execute(task, state, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历所有规则</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        Spec&lt;? <span class="keyword">super</span> T&gt;[] specs = getSpecsArray();</span><br><span class="line">        <span class="keyword">for</span> (Spec&lt;? <span class="keyword">super</span> T&gt; spec : specs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!spec.isSatisfiedBy(object)) &#123;</span><br><span class="line">								<span class="comment">//只要有一个规则不通过，则返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-onlyIf用法"><a href="#2-2-onlyIf用法" class="headerlink" title="2.2 onlyIf用法"></a>2.2 onlyIf用法</h2><p>那么，我么怎么使用<code>onlyIf</code>呢？</p>
<h3 id="2-2-1-自定义规则作为唯一判断条件"><a href="#2-2-1-自定义规则作为唯一判断条件" class="headerlink" title="2.2.1 自定义规则作为唯一判断条件"></a>2.2.1 自定义规则作为唯一判断条件</h3><p>这里用<code>=</code>即可。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task foo&#123;</span><br><span class="line">	onlyIf = &#123;<span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">foo.onlyIf = &#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以从gradle源码<code>AbstractTask#setOnlyIf</code> 看出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnlyIf</span><span class="params">(<span class="keyword">final</span> Closure onlyIfClosure)</span> </span>&#123;</span><br><span class="line">       taskMutator.mutate(<span class="string">&quot;Task.setOnlyIf(Closure)&quot;</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//设置onlyIfClosure并覆盖原有的onlyIfSpec</span></span><br><span class="line">               onlyIfSpec = createNewOnlyIfSpec().and(onlyIfClosure);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的默认返回为true的element</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AndSpec&lt;Task&gt; <span class="title">createNewOnlyIfSpec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> AndSpec&lt;Task&gt;(<span class="keyword">new</span> Spec&lt;Task&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Task element)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//调用方: task.isSatisfiedBy(task)</span></span><br><span class="line">               <span class="keyword">return</span> element == AbstractTask.<span class="keyword">this</span> &amp;&amp; enabled;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-自定义规则作为条件判断的一部分"><a href="#2-2-2-自定义规则作为条件判断的一部分" class="headerlink" title="2.2.2 自定义规则作为条件判断的一部分"></a>2.2.2 自定义规则作为条件判断的一部分</h3><p>去掉<code>=</code>即可</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task foo&#123;</span><br><span class="line">	onlyIf &#123;<span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">foo.onlyIf &#123;<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>源码部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyIf</span><span class="params">(<span class="keyword">final</span> Closure onlyIfClosure)</span> </span>&#123;</span><br><span class="line">       taskMutator.mutate(<span class="string">&quot;Task.onlyIf(Closure)&quot;</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//插入</span></span><br><span class="line">               onlyIfSpec = onlyIfSpec.and(onlyIfClosure);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以方便我们定义多个<code>onlyIf</code>块，同时也可以保证不会覆盖系统默认的<code>onlyIf</code>。接下来我们来聊聊<code>jacocoTestReport</code>预置的<code>onlyIf</code></p>
<h1 id="3-jacocoTestReport的onlyIf为什么”默认”是false"><a href="#3-jacocoTestReport的onlyIf为什么”默认”是false" class="headerlink" title="3. jacocoTestReport的onlyIf为什么”默认”是false"></a>3. <code>jacocoTestReport</code>的<code>onlyIf</code>为什么”默认”是<code>false</code></h1><p>从上面的分析可知<code>jacocoTestReport</code>会被跳过显然是<code>isSatisfiedBy</code>返回了false。而正常情况通过<code>createNewOnlyIfSpec()</code>初始化的<code>spec</code>其<code>isSatisfiedBy</code>返回的必然是true。所以，肯定是什么地方添加了额外的<code>spec</code>。我们先看看<code>JacocoReport</code>这种类型的<code>Task</code>是如何初始化的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  JacocoReport extends JacocoReportBase</span></span><br><span class="line"><span class="comment"> *  JacocoReportBase extends AbstractTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JacocoReportBase</span> <span class="keyword">extends</span> <span class="title">JacocoBase</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> JacocoReportBase() &#123;</span><br><span class="line">		<span class="comment">//添加spec</span></span><br><span class="line">        onlyIf(<span class="keyword">new</span> Spec&lt;Task&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isSatisfiedBy(Task element) &#123;</span><br><span class="line">                <span class="keyword">return</span> Iterables.any(getExecutionData(), <span class="keyword">new</span> Predicate&lt;File&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">boolean</span> apply(File file) &#123;</span><br><span class="line">                    	<span class="comment">//返回文件是否存在</span></span><br><span class="line">                        <span class="keyword">return</span> file.exists();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JacocoReport</code>在初始化时会添加一个验证规则，如果<code>getExecutionData()</code>对应的文件都存在，则返回<code>true</code>，否则返回<code>false</code> 。那么，<code>onlyIf</code>“默认”为<code>false</code>，显然是<code>getExecutionData()</code>返回的文件路径中有的文件不存在。接下来我们研究为什么会有文件不存在的问题。</p>
<h1 id="4-jacocoTestReport的executionData为什么会默认包含”test-exec”"><a href="#4-jacocoTestReport的executionData为什么会默认包含”test-exec”" class="headerlink" title="4. jacocoTestReport的executionData为什么会默认包含”test.exec”"></a>4. <code>jacocoTestReport</code>的<code>executionData</code>为什么会默认包含”test.exec”</h1><p>经过上述分析，我们知道只要为task设置<code>onlyIf=&#123;true&#125;</code>之后，task就必然会执行。通过添加onlyIf={true}，<code>jacocoTestReport</code>开始运行。这是突然又得到一个错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to read execution data file /xxx/test.exec</span><br></pre></td></tr></table></figure>

<p>很奇怪，明明我们设置的<code>executionData</code>是<code>serviceTest.exec</code>，为什么<code>jacocoTestReport</code>会去查找<code>test.exec</code>呢？显然，这又是被预置的行为。所以，我们先来看看<code>jacocoTestReport</code>这个<code>Task</code>是在哪里创建出来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TASK_NAME = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacocoPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultReportAndCoverageVerificationTasks</span><span class="params">(<span class="keyword">final</span> JacocoPluginExtension extension)</span> </span>&#123;</span><br><span class="line">        project.getPlugins().withType(JavaPlugin.class, javaPlugin -&gt; &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取test Task</span></span><br><span class="line">            TaskProvider&lt;Task&gt; testTaskProvider = project.getTasks().named(JavaPlugin.TEST_TASK_NAME);</span><br><span class="line">			<span class="comment">//初始化jacocoTestReport Task</span></span><br><span class="line">            addDefaultReportTask(extension, testTaskProvider);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultReportTask</span><span class="params">(<span class="keyword">final</span> JacocoPluginExtension extension, <span class="keyword">final</span> TaskProvider&lt;Task&gt; testTaskProvider)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//testTaskName是常量test</span></span><br><span class="line">        <span class="keyword">final</span> String testTaskName = testTaskProvider.getName();</span><br><span class="line">		<span class="comment">//注册jacocoTestReport Task</span></span><br><span class="line">        project.getTasks().register(</span><br><span class="line">            <span class="string">&quot;jacoco&quot;</span> + StringUtils.capitalize(testTaskName) + <span class="string">&quot;Report&quot;</span>,</span><br><span class="line">            JacocoReport.class,</span><br><span class="line">            reportTask -&gt; &#123;</span><br><span class="line">				<span class="comment">//定义该Task的默认配置项</span></span><br><span class="line">				...</span><br><span class="line">				<span class="comment">//设置executionData为test里定义的destinationFile</span></span><br><span class="line">                reportTask.executionData(testTaskProvider.get());</span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JacocoReportBase</span> <span class="keyword">extends</span> <span class="title">JacocoBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executionData</span><span class="params">(Task... tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">			<span class="comment">//拿到传入task里定义的jacoco extension,也就是jacoco&#123;&#125;定义的内容</span></span><br><span class="line">            <span class="keyword">final</span> JacocoTaskExtension extension = task.getExtensions().findByType(JacocoTaskExtension.class);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executionData(<span class="keyword">new</span> Callable&lt;File&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> File <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="comment">//设置executionData为task里定义的destinationFile</span></span><br><span class="line">                        <span class="keyword">return</span> extension.getDestinationFile();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                mustRunAfter(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JacocoPlugin</code>在初始化时会注册一个类型为<code>JacocoReport</code>而名称为<code>jacocoTestReport</code>的<code>Task</code>，这个<code>Task</code>的<code>executionData</code>默认设置为test Task的<code>jacoco extension</code>中定义的<code>destinationFile</code>。而上文中的<code>test</code>的<code>jacoco extension</code>里定义的<code>destinationFile</code>正好是<code>layout.buildDirectory.file(&quot;jacoco/$&#123;taskName&#125;.exec&quot;).get().asFile</code>。所以到这里其实也就真相大白了。</p>
<p>事实上，类型为<code>Test</code>的<code>Task</code>的<code>jacoco extension</code>的<code>destinationFile</code>默认值就是<code>layout.getBuildDirectory().file(&quot;jacoco/&quot; + taskName + &quot;.exec&quot;).map(RegularFile::getAsFile)</code>。所以，如果我们没有定义这个值，也会报出同样的错误。源码部分如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacocoPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        JacocoPluginExtension extension = project.getExtensions().create(PLUGIN_EXTENSION_NAME, JacocoPluginExtension.<span class="keyword">class</span>, project, agent);</span><br><span class="line">        <span class="comment">//为test设置默认jacoco extension</span></span><br><span class="line">        applyToDefaultTasks(extension);</span><br><span class="line">        <span class="comment">//初始化默认jacocoTestReport</span></span><br><span class="line">        addDefaultReportAndCoverageVerificationTasks(extension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> applyToDefaultTasks(<span class="keyword">final</span> JacocoPluginExtension extension) &#123;</span><br><span class="line">		<span class="comment">//拿到所有test Task并配置jacoco extension</span></span><br><span class="line">        project.getTasks().withType(Test.<span class="keyword">class</span>).configureEach(<span class="attr">extension:</span>:applyTo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacocoPluginExtension</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T <span class="keyword">extends</span> Task &amp; JavaForkOptions&gt; <span class="keyword">void</span> applyTo(<span class="keyword">final</span> T task) &#123;</span><br><span class="line">        <span class="keyword">final</span> String taskName = task.getName();</span><br><span class="line">        <span class="keyword">final</span> JacocoTaskExtension extension = task.getExtensions().create(TASK_EXTENSION_NAME, JacocoTaskExtension.<span class="keyword">class</span>, objects, agent, task);</span><br><span class="line">		<span class="comment">//设置文件名为$&#123;taskName&#125;.exec。test Task对应的就是test.exec</span></span><br><span class="line">        extension.setDestinationFile(layout.getBuildDirectory().file(<span class="string">&quot;jacoco/&quot;</span> + taskName + <span class="string">&quot;.exec&quot;</span>).map(<span class="attr">RegularFile:</span>:getAsFile));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-怎么实现最初的目标"><a href="#5-怎么实现最初的目标" class="headerlink" title="5. 怎么实现最初的目标"></a>5. 怎么实现最初的目标</h1><p>既然我们知道了<code>jacocoTestReport</code>里预设了<code>executionData</code>，那么要实现最初目标，我们只需要在执行<code>task</code>时把它清空并重新设置，或者自定义一个干净的<code>JacocoReport</code>即可。</p>
<h2 id="5-1-清空并重新设置"><a href="#5-1-清空并重新设置" class="headerlink" title="5.1 清空并重新设置"></a>5.1 清空并重新设置</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">jacocoTestReport &#123;</span><br><span class="line">    <span class="comment">// tests are required to run before generating the report</span></span><br><span class="line">    dependsOn serviceTest</span><br><span class="line">		<span class="comment">//清空预设的executionData</span></span><br><span class="line">		((DefaultConfigurableFileCollection) executionData).filesWrapper.clear();</span><br><span class="line">		<span class="comment">//指定覆盖率统计数据文件。</span></span><br><span class="line">		executionData(layout.buildDirectory.file(<span class="string">&quot;jacoco/$&#123;serviceTest.name&#125;.exec&quot;</span>).get().asFile)</span><br><span class="line"></span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        classDirectories.setFrom(files(classDirectories.files.collect &#123;</span><br><span class="line">            fileTree(<span class="attr">dir:</span> it, <span class="attr">include:</span> [<span class="string">&#x27;xxxservice&#x27;</span>])</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.required = <span class="literal">false</span></span><br><span class="line">        csv.required = <span class="literal">false</span></span><br><span class="line">        html.outputLocation = layout.buildDirectory.dir(<span class="string">&#x27;jacocoReport&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-自定义一个干净的JacocoReport"><a href="#5-2-自定义一个干净的JacocoReport" class="headerlink" title="5.2 自定义一个干净的JacocoReport"></a>5.2 自定义一个干净的<code>JacocoReport</code></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task jacocoServiceTestReport(<span class="attr">type:</span> JacocoReport) &#123;</span><br><span class="line">    <span class="comment">// tests are required to run before generating the report</span></span><br><span class="line">    dependsOn serviceTest</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的不会初始化源码目录，需要手动指定</span></span><br><span class="line">    sourceSets sourceSets.main</span><br><span class="line"></span><br><span class="line">    executionData(layout.buildDirectory.file(<span class="string">&quot;jacoco/$&#123;serviceTest.name&#125;.exec&quot;</span>).get().asFile)</span><br><span class="line"></span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        classDirectories.setFrom(files(classDirectories.files.collect &#123;</span><br><span class="line">            fileTree(<span class="attr">dir:</span> it, <span class="attr">include:</span> project.ext.serviceSources)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.required = <span class="literal">false</span></span><br><span class="line">        csv.required = <span class="literal">false</span></span><br><span class="line">        html.outputLocation = layout.buildDirectory.dir(project.ext.reportDir <span class="keyword">as</span> String)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onlyIf = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些唠叨-没什么营养，可跳过"><a href="#一些唠叨-没什么营养，可跳过" class="headerlink" title="一些唠叨(没什么营养，可跳过)"></a>一些唠叨(没什么营养，可跳过)</h1><p>当时碰到这个问题，没有头绪。就跑到<code>StackOverFlow</code>上瞎逛过一圈。其中有一个<a href="https://stackoverflow.com/questions/61070848/configure-jacocotestreport-to-read-multiple-exec-files-as-input/69210870#69210870">相同的问题</a>，但下面的解答不对。最后还是我解决问题后跑到下面给了解答(作为一个<code>gradle</code>菜鸟，能帮助到他人，很开心😃!)。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为对<code>gradle</code>跟<code>jacoco</code>不怎么熟，当时看到唯一的提示信息：<code>jacocoTestReport SKIPPED</code>我是一脸懵逼的。好在当时从<a href="https://stackoverflow.com/questions/39610659/eclipse-java-gradle-is-skipping-jacocotestreport">stackOverFlow</a>以及<a href="https://github.com/gradle/gradle/issues/18271">官方</a>那里得到了一个切入点：<code>onlyIf=&#123;true&#125;</code>。让问题最终得以解决。</p>
<p>另一方面，我觉得官方在这一块的sample略显简陋，这些默认行为至少应该提一下，否则很容易让人摸不着头脑。所以我翻文档终究没有翻出解决方案(如果有哪位朋友发现官方文档有过这方面的描述，欢迎指出👏)。</p>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/scientificCommunity/blog-sample/blob/feature/unit-test-sample/unit-test-sample/unitTest.gradle">github</a></h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈之非root用户运行docker命令</title>
    <url>/posts/10743/</url>
    <content><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-将用户添加至docker组中"><a href="#1-将用户添加至docker组中" class="headerlink" title="1. 将用户添加至docker组中"></a>1. 将用户添加至docker组中</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -aG docker currUser</span><br></pre></td></tr></table></figure>
<p><code>docker</code>命令本质上是通过访问(读写)<code>/var/run/docker.sock</code>来完成与<code>docker</code>的交互。<code>/var/run/docker.sock</code>默认属于<code>docker</code>组以及<code>root</code>用户，所以，要想获得<code>docker</code>命令执行权，需要将用户添加到<code>docker</code>组中。<br>ps: 如果docker组不存在，则需先执行：<code>sudo groupadd docker</code></p>
<h2 id="2-切换到docker组"><a href="#2-切换到docker组" class="headerlink" title="2. 切换到docker组"></a>2. 切换到docker组</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option">daemon-socket-option</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>vert.x源码浅析之redis集成</title>
    <url>/posts/4fc0a6f7/</url>
    <content><![CDATA[<h1 id="vertx是什么"><a href="#vertx是什么" class="headerlink" title="vertx是什么"></a>vertx是什么</h1><p>vert.x是一个全异步框架，通过内部的event bus跟event loop做到了处处皆异步。关于里面的细节，后面我会出一篇文章详细跟大家探讨…</p>
<h1 id="为什么要用vertx"><a href="#为什么要用vertx" class="headerlink" title="为什么要用vertx"></a>为什么要用vertx</h1><p>充分利用机器性能，提升应用的吞吐量上限。</p>
<h1 id="vertx-redis-client是什么"><a href="#vertx-redis-client是什么" class="headerlink" title="vertx-redis-client是什么"></a>vertx-redis-client是什么</h1><p>通俗来讲，vertx-redis提供了一个<code>全异步</code>的可配置的<code>redis客户端</code></p>
<h1 id="vertx-redis-client有哪些特性"><a href="#vertx-redis-client有哪些特性" class="headerlink" title="vertx-redis-client有哪些特性"></a>vertx-redis-client有哪些特性</h1><p>相对常规的jedis或者Lettuce来说，这里的特性其实就是vertx贯穿全局的特性：异步。当我们调用api发送一条redis指令的时候，可以<code>不用等待</code>redis的响应，只需要绑定一个<code>回调函数</code>，程序就可以继续往下执行。当拿到redis的响应之后，就会触发这个回调。当然，像这种编程方式，需要把<code>业务依赖关系</code>处理得很明确，因为我们必须把依赖这个redis响应的所有处理都移到这个回调函数里去。</p>
<h1 id="怎么使用vertx-redis-client"><a href="#怎么使用vertx-redis-client" class="headerlink" title="怎么使用vertx-redis-client"></a>怎么使用vertx-redis-client</h1><h2 id="添加vertx-redis-client依赖"><a href="#添加vertx-redis-client依赖" class="headerlink" title="添加vertx-redis-client依赖"></a>添加vertx-redis-client依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gradle</span></span><br><span class="line">compile(<span class="string">&quot;io.vertx:vertx-redis-client:$version&quot;</span>)</span><br><span class="line"><span class="comment">//maven</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.vertx&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;vertx-redis-client&lt;/artifactId&gt;</span><br><span class="line">  &lt;vertion&gt;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="RedisConnection"><a href="#RedisConnection" class="headerlink" title="RedisConnection"></a>RedisConnection</h2><p>RedisConnection是vertx-redis-client里暴露出来可操作redis的最基本的一组api了，使用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redis</span><br><span class="line">  .createClient(Vertx.vertx(), <span class="string">&quot;redis://ip:port&quot;</span>)</span><br><span class="line">  .connect(onConnect -&gt; &#123;</span><br><span class="line">     <span class="comment">//连接成功</span></span><br><span class="line">     <span class="keyword">if</span> (onConnect.succeeded()) &#123;</span><br><span class="line">         <span class="comment">//获取连接实例</span></span><br><span class="line">         RedisConnection conn = onConnect.result();</span><br><span class="line">         <span class="comment">//创建redis get指令. </span></span><br><span class="line">         Request command = Request.cmd(Command.GET);</span><br><span class="line">         <span class="comment">//添加指令参数aa. 最后到达redis的指令就是get aa</span></span><br><span class="line">         command.arg(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">         <span class="comment">//发送指令</span></span><br><span class="line">         conn.send(command, resp -&gt; &#123;</span><br><span class="line">             <span class="comment">//执行成功</span></span><br><span class="line">             <span class="keyword">if</span> (resp.succeeded()) &#123;</span><br><span class="line">                 <span class="comment">//拿到指令执行结果</span></span><br><span class="line">                 Response result = resp.result();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>这里就谈谈怎么使用吧，其实内部的实现就是通过netty包装的channel跟redis建立起连接，有兴趣的朋友可以点进去看看。</p>
<h2 id="redisOptions"><a href="#redisOptions" class="headerlink" title="redisOptions"></a>redisOptions</h2><p>在介绍该redisClient各种模式之前，我们需要了解options是什么。<br>简单来说，redisOptions是我们用来定制该redisClient的一种方式，像之前我们通过==Redis.createClient(Vertx.vertx(), “redis://ip:port”)== 这种仅仅提供一个地址的方式就建立起了一个redisClient，但是如果我们想要定制更复杂的redisClient呢？这个时候就需要用到redisOptions了</p>
<h3 id="各项主要配置的含义"><a href="#各项主要配置的含义" class="headerlink" title="各项主要配置的含义"></a>各项主要配置的含义</h3><p>先大概看下redisOptions都有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisOptions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default redis endpoint = &#123;<span class="doctag">@code</span> redis://localhost:6379&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ENDPOINT = <span class="string">&quot;redis://localhost:6379&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> RedisClientType type;</span><br><span class="line">  <span class="keyword">private</span> NetClientOptions netClientOptions;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; endpoints;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxWaitingHandlers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxNestedArrays;</span><br><span class="line">  <span class="keyword">private</span> String masterName;</span><br><span class="line">  <span class="keyword">private</span> RedisRole role;</span><br><span class="line">  <span class="keyword">private</span> RedisSlaves slaves;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pool related options</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> poolCleanerInterval;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxPoolWaiting;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> poolRecycleTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>该枚举用于指定redisClient以什么模式去连接server，这里的模式跟redis server的模式一一对应，我们在用的时候也必须注意，server是以什么模式部署的，client就以什么模式去配置。源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RedisClientType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认值，单机模式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  STANDALONE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 哨兵</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  SENTINEL,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 集群</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CLUSTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些配置决定了redisClient与server交互的方式，不同的类型会用不同的策略来应对，在我们调用Redis#creatClient的时候就会作出处理，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Redis <span class="title">createClient</span><span class="params">(Vertx vertx, RedisOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (options.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STANDALONE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisClient(vertx, options);</span><br><span class="line">      <span class="keyword">case</span> SENTINEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSentinelClient(vertx, options);</span><br><span class="line">      <span class="keyword">case</span> CLUSTER:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisClusterClient(vertx, options);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown Redis Client type: &quot;</span> + options.getType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至于不同Client内部是怎么处理的，后面会一一介绍</p>
<h4 id="masterName"><a href="#masterName" class="headerlink" title="masterName"></a>masterName</h4><p>这个只在Sentinel模式下有用，跟redisServer的redis_sentinel.conf里配置的masterName是一个东西，用来指明连接的是被哨兵监控的哪一个主从集群</p>
<h4 id="role"><a href="#role" class="headerlink" title="role"></a>role</h4><p>这项配置只用于clientType为Sentinel的情况，主要用来指定当前的客户端到底是跟master连接还是只跟slave连接，如果配置为slave，则通过该客户端发起的所有指令都会被路由到slave节点，这意味着这个client对redisServer的所有操作都是只读的。<br>还有一个sentinel，这个意味着这个client只操作server端的sentinel，不会主动去获取到master或者slave的连接。按我目前看来，这个枚举值其实是给程序内部使用的，除非我们想手动实现跟哨兵的通信以及维护相应主从节点的一个failover情况，那么就可以使用这个配置。核心源码在RedisSentinelClient中，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createConnectionInternal</span><span class="params">(RedisOptions options, RedisRole role, Handler&lt;AsyncResult&lt;RedisConnection&gt;&gt; onCreate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (role) &#123;</span><br><span class="line">      <span class="keyword">case</span> SENTINEL:</span><br><span class="line">        resolveClient(<span class="keyword">this</span>::isSentinelOk, options, createAndConnect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> MASTER:</span><br><span class="line">        resolveClient(<span class="keyword">this</span>::getMasterFromEndpoint, options, createAndConnect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> SLAVE:</span><br><span class="line">        resolveClient(<span class="keyword">this</span>::getSlaveFromEndpoint, options, createAndConnect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  这里可以看到，根据不同的role，获取了不同类型的redis连接地址<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMasterFromEndpoint</span><span class="params">(String endpoint, RedisOptions options, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> RedisURI uri = <span class="keyword">new</span> RedisURI(endpoint);</span><br><span class="line">  connectionManager.getConnection(context, getSentinelEndpoint(uri), <span class="keyword">null</span>, onCreate -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> RedisConnection conn = onCreate.result();</span><br><span class="line">    <span class="keyword">final</span> String masterName = options.getMasterName();</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 根据masterName从sentinel获取相应主从集群的master节点信息</span></span><br><span class="line">    conn.send(cmd(SENTINEL).arg(<span class="string">&quot;GET-MASTER-ADDR-BY-NAME&quot;</span>).arg(masterName), getMasterAddrByName -&gt; &#123;</span><br><span class="line">      <span class="comment">//bala bala...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSlaveFromEndpoint</span><span class="params">(String endpoint, RedisOptions options, Handler&lt;AsyncResult&lt;String&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> RedisURI uri = <span class="keyword">new</span> RedisURI(endpoint);</span><br><span class="line">    connectionManager.getConnection(context, getSentinelEndpoint(uri), <span class="keyword">null</span>, onCreate -&gt; &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> RedisConnection conn = onCreate.result();</span><br><span class="line">      <span class="keyword">final</span> String masterName = options.getMasterName();</span><br><span class="line">      <span class="comment">// 获取masterName指定主从的slave节点</span></span><br><span class="line">      conn.send(cmd(SENTINEL).arg(<span class="string">&quot;SLAVES&quot;</span>).arg(masterName), sentinelSlaves -&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="slaves"><a href="#slaves" class="headerlink" title="slaves"></a>slaves</h4><p>这项配置用来指定在集群模式下对server的读操作的行为，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RedisSlaves</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读操作只落在master</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  NEVER,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读操作会随机落在master跟slave</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  SHARE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读操作只落在slave上</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ALWAYS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心原理是通过对slave节点执行readonly命令来开启slave的查询功能，因为默认集群模式下slave是不对外提供服务的。核心源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(List&lt;String&gt; endpoints, <span class="keyword">int</span> index, Handler&lt;AsyncResult&lt;RedisConnection&gt;&gt; onConnect)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果RedisSlaves的值不是NEVER,就执行readonly</span></span><br><span class="line">    connectionManager.getConnection(context, endpoints.get(index), RedisSlaves.NEVER != options.getUseSlave() ? cmd(READONLY) : <span class="keyword">null</span>, getConnection -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poolCleanerInterval"><a href="#poolCleanerInterval" class="headerlink" title="poolCleanerInterval"></a>poolCleanerInterval</h4><p>连接池空闲连接清理间隔，每次扫描时会直接将闲置的连接关闭。<code>-1</code>表示不开启空闲连接清理，核心源码在RedisConnectionManager#start()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> period = options.getPoolCleanerInterval();</span><br><span class="line">    <span class="comment">//延迟period时间后执行checkExpired()进行空闲连接清理</span></span><br><span class="line">    <span class="keyword">this</span>.timerID = period &gt; <span class="number">0</span> ? vertx.setTimer(period, id -&gt; checkExpired(period)) : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="poolRecycleTimeout"><a href="#poolRecycleTimeout" class="headerlink" title="poolRecycleTimeout"></a>poolRecycleTimeout</h4><p>这个是用来控制连接池中连接在执行完命令后还能存活的时间，超过这个时间连接就会被关闭，核心源码在<code>RedisStandaloneConnection</code>。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expirationTimestamp &gt; <span class="number">0</span> &amp;&amp; System.currentTimeMillis() &lt;= expirationTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recycle this connection from the pool</span></span><br><span class="line">    expirationTimestamp = recycleTimeout &gt; <span class="number">0</span> ? System.currentTimeMillis() + recycleTimeout : <span class="number">0L</span>;</span><br><span class="line">    listener.onRecycle();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="maxPoolSize"><a href="#maxPoolSize" class="headerlink" title="maxPoolSize"></a>maxPoolSize</h4><p>连接池最大大小。<code>只有当等待获取连接的请求数量达到maxPoolWaiting时才会创建新的连接</code>，可以类比<code>ThreadPoolExecutor</code>的<code>maximumPoolSize</code></p>
<h4 id="maxPoolWaiting"><a href="#maxPoolWaiting" class="headerlink" title="maxPoolWaiting"></a>maxPoolWaiting</h4><p>连接池等待队列大小。当我们通过RedisClient或者RedisApi去操作reids时，如果当前已无空闲的redis连接，那么这个请求就会进入连接池的等待队列中。可以类比<code>ThreadPoolExecutor</code>的<code>workQueue</code></p>
<h4 id="maxWaitingHandlers"><a href="#maxWaitingHandlers" class="headerlink" title="maxWaitingHandlers"></a>maxWaitingHandlers</h4><p>等待执行的handler数的最大值。当我们发送完redis指令后，一般是需要对这个响应作出处理，这个过程会被包装成一个<code>task</code>添加到<code>eventLoop</code>的<code>waitQueue</code>中，这项配置控制的就是这个<code>queue</code>的<code>size</code></p>
<h2 id="RedisClient"><a href="#RedisClient" class="headerlink" title="RedisClient"></a>RedisClient</h2><p>redisClient本质是对上述redisConnection的再封装，提供了针对redisServer不同模式的不同处理，分为3种：单机，哨兵以及集群模式。对应到具体的class：<code>RedisClient</code>、<code>RedisSentinelClient</code>、<code>RedisSentinelClient</code><br>接下来来看一下如何配置这些客户端</p>
<h3 id="STANDALONE"><a href="#STANDALONE" class="headerlink" title="STANDALONE"></a>STANDALONE</h3><p>这个是redisClient默认的一种配置模式，现在我们用前面描述的redisOptions实践一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisOptions options = <span class="keyword">new</span> RedisOptions();</span><br><span class="line">options.setType(RedisClientType.STANDALONE)</span><br><span class="line">        <span class="comment">//指定server地址</span></span><br><span class="line">        .setConnectionString(<span class="string">&quot;redis://ip:port&quot;</span>)</span><br><span class="line">        .setMaxPoolSize(<span class="number">6</span>)</span><br><span class="line">        .setMaxWaitingHandlers(<span class="number">1024</span>)</span><br><span class="line">        .setPoolRecycleTimeout(<span class="number">15_000</span>)</span><br><span class="line">        .setMaxPoolWaiting(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Redis client = Redis.createClient(Vertx.vertx(), options);</span><br><span class="line"><span class="comment">//创建redis 指令. get</span></span><br><span class="line">Request command = Request.cmd(Command.GET);</span><br><span class="line"><span class="comment">//添加指令参数aa. 最后到达redis的指令就是get aa</span></span><br><span class="line">command.arg(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="comment">//发送指令并指定一个匿名handler处理结果</span></span><br><span class="line">client.send(command).onComplete(event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;the value of redis key &#x27;aa&#x27; is&quot;</span>+event.result().toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="SENTINEL"><a href="#SENTINEL" class="headerlink" title="SENTINEL"></a>SENTINEL</h3><p>这里请原谅我秀了一下我那蹩脚的英语水平…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisOptions options = <span class="keyword">new</span> RedisOptions();</span><br><span class="line">options.setType(RedisClientType.SENTINEL)</span><br><span class="line">        <span class="comment">//the master name which are monitored by sentinels</span></span><br><span class="line">        .setMasterName(<span class="string">&quot;myMaster&quot;</span>)</span><br><span class="line">        .setRole(RedisRole.MASTER)</span><br><span class="line">        .setMaxPoolSize(<span class="number">6</span>)</span><br><span class="line">        .setMaxWaitingHandlers(<span class="number">1024</span>)</span><br><span class="line">        .setPoolRecycleTimeout(<span class="number">15_000</span>)</span><br><span class="line">        .setMaxPoolWaiting(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里只填哨兵的地址就行了</span></span><br><span class="line"><span class="comment">//程序会自动从哨兵处获取节点信息</span></span><br><span class="line">List&lt;String&gt; sentinels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">sentinels.add(<span class="string">&quot;redis://ip:port&quot;</span>);</span><br><span class="line">sentinels.add(<span class="string">&quot;redis://ip:port&quot;</span>);</span><br><span class="line">options.setEndpoints(sentinels);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里可以只填一个哨兵地址，由于client不会主动去连接监控同一个master的哨兵节点，所以一旦这个唯一的哨兵挂了，那么server就会处于不可用的状态。</p>
<h3 id="CLUSTER"><a href="#CLUSTER" class="headerlink" title="CLUSTER"></a>CLUSTER</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   RedisOptions options = <span class="keyword">new</span> RedisOptions();</span><br><span class="line">   options.setType(RedisClientType.CLUSTER)</span><br><span class="line">           .setUseSlave(RedisSlaves.NEVER)</span><br><span class="line">           .setMaxPoolSize(<span class="number">6</span>)</span><br><span class="line">           .setMaxWaitingHandlers(<span class="number">1024</span>)</span><br><span class="line">           .setPoolRecycleTimeout(<span class="number">15_000</span>)</span><br><span class="line">           .setMaxPoolWaiting(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//添加集群节点，越多越好...</span></span><br><span class="line">   List&lt;String&gt; clusters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   sentinels.add(<span class="string">&quot;redis://ip:port&quot;</span>);</span><br><span class="line">   sentinels.add(<span class="string">&quot;redis://ip:port&quot;</span>);</span><br><span class="line">   sentinels.add(<span class="string">&quot;redis://ip:port&quot;</span>);</span><br><span class="line">   options.setEndpoints(clusters);</span><br></pre></td></tr></table></figure>
<p>这里也需要注意最好将cluster中所有的节点信息给添加进来。虽然连接任意一个节点，client都会通过执行<code>cluster slots</code>获取cluster中所有节点的信息，但是长久保持连接的只有我们在这里设置进去的节点。这意味着一旦我们手动设置的节点挂了，那么server对我们来说就不可用了</p>
<h2 id="RedisApi"><a href="#RedisApi" class="headerlink" title="RedisApi"></a>RedisApi</h2><p>这个是基于<code>RedisClient</code>的封装，隐藏了<code>Command</code>的复杂细节，提供了一套可以直接调用的api。使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redis client = Redis.createClient(Vertx.vertx(), options);</span><br><span class="line">RedisAPI api = RedisAPI.api(client);</span><br><span class="line">api.get(<span class="string">&quot;aa&quot;</span>).onComplete(event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;the value of redis key &#x27;aa&#x27; is&quot;</span> + event.result().toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全文描述了vertx-client是什么以及其相对某些redis-client所具备的特点。同时深挖了这个客户端各项配置的作用以及不同模式下的表现。<br>总的来说，这篇文章可以帮助大家去建立一个<code>基于vertx的redis客户端</code>，并且对这个客户端能够做到基本的<code>知其然且知其所以然</code>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>源码</tag>
        <tag>浅析</tag>
        <tag>vertx</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试之浅析Mockito mock Kotlin Object类方法</title>
    <url>/posts/48796/</url>
    <content><![CDATA[<p><code>Kotlin</code>里有一种<code>object</code>类型的类，它在使用上跟<code>Java</code>里的静态类很相似。事实上，它们编译后确实很相似，只不过<code>Kotlin</code>在语法层面上隐藏了一些实现细节，这些细节如果不清楚的话往往会引发一些意料之外的错误。<br><code>Mockito</code>是可以直接<code>mock</code>静态方法的，而<code>Mockito</code>在<code>mock</code>这种<code>Kotlin</code>类里定义的”静态方法”时却会直接报错，为什么呢？</p>
<p>比如我创建一个<code>Kotlin</code> <code>Object</code>类：<code>ObjectMethod</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baichuan.example.unit_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ObjectMethod &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;this is ObjectMethod#doSomething&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingWithJvmStatic</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;this is ObjectMethod#doSomethingWithJvmStatic&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我直接去<code>mock</code>该类的<code>doSomething</code>方法，会报错。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;mock普通的kotlin静态方法&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testMockKotlinObject</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Assertions.assertThrows(MissingMethodInvocationException::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">        Mockito.mockStatic(ObjectMethod::<span class="keyword">class</span>.java).`<span class="keyword">when</span>`&lt;<span class="built_in">Unit</span>&gt;(</span><br><span class="line">            ObjectMethod::doSomething</span><br><span class="line">        ).thenAnswer &#123; println(<span class="string">&quot;this is mocked Object#doSomething&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectMethod.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为<code>kotlin</code>里的<code>object</code>类里的方法虽然在<code>kotlin</code>里从形态跟使用上来看与静态方法无二。但是编译成<code>java</code>代码后，其本质其实是内部初始化了一个当前类的静态常量实例<code>INSTANCE</code>。这个<code>INSTANCE</code>在<code>kotlin</code>语法里被隐藏了，但在java里依然可以显示访问。<code>ObjectMethod</code>编译成<code>java</code>后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMethod</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMethod INSTANCE = <span class="keyword">new</span> ObjectMethod();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ObjectMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String var1 = <span class="string">&quot;this is ObjectMethod#doSomething&quot;</span>;</span><br><span class="line">      <span class="keyword">boolean</span> var2 = <span class="keyword">false</span>;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmStatic</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomethingWithJvmStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String var0 = <span class="string">&quot;this is ObjectMethod#doSomethingWithJvmStatic&quot;</span>;</span><br><span class="line">      <span class="keyword">boolean</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">      System.out.println(var0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，不能<code>mock</code> <code>ObjectMethod#doSomething</code>本质上的原因是正常手段无法<code>mock</code>静态常量。如果想要使<code>kotlin</code>的<code>object</code>类中的方法能够被<code>mock</code>，只需在方法上加上<code>@JvmStatic</code>注解即可。被其标注的方法会被编译成普通的<code>java</code>静态方法。</p>
<p>上面说正常手段无法mock静态常量，那么非正常手段呢？其实这个非正常手段就是通过反射将被<code>mock</code>过的实例注入到<code>ObjectMethod</code>中即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="meta-string">&quot;通过反射修改静态常量来mock普通的kotlin静态方法&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testMockKotlinObjectMethodByReflection</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mock = Mockito.mock(ObjectMethod::<span class="keyword">class</span>.java)</span><br><span class="line">    Mockito.`<span class="keyword">when</span>`(mock.doSomething()).then &#123;</span><br><span class="line">        print(<span class="string">&quot;this is mocked ObjectMethod by reflection&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> declaredMethod = ObjectMethod::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>)</span><br><span class="line">    ReflectionUtils.setFinalStatic(declaredMethod, mock)</span><br><span class="line"></span><br><span class="line">    ObjectMethod.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReflectionUtils</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baichuan.example.unit_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> ReflectionUtils &#123;</span><br><span class="line">    <span class="meta">@Throws(Exception::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setFinalStatic</span><span class="params">(field: <span class="type">Field</span>, newValue: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        field.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> modifiersField: Field = Field::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>)</span><br><span class="line">        modifiersField.isAccessible = <span class="literal">true</span></span><br><span class="line">        modifiersField.setInt(field, field.modifiers and Modifier.FINAL.inv())</span><br><span class="line">        field.<span class="keyword">set</span>(<span class="literal">null</span>, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/scientificCommunity/blog-sample/tree/main/unit-test-sample">github</a></h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑日记之Springfox+Kotlin lateinit引发NullPointException</title>
    <url>/posts/4a9faf5f/</url>
    <content><![CDATA[<h1 id="相关技术栈"><a href="#相关技术栈" class="headerlink" title="相关技术栈"></a>相关技术栈</h1><p><code>Kotlin1.5</code>  <code>Springboot2.5</code> <code>Springfox3.0</code></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近对接支付宝的电脑网站支付，需要定义一个支持表单Post提交的接口来接收支付宝的回调。在定义完接口后发现<code>Springfox</code>初始化<code>swagger</code>时报了空指针，导致<code>swagger api doc</code>无法加载</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="1-报错位置"><a href="#1-报错位置" class="headerlink" title="1. 报错位置"></a>1. 报错位置</h2><p><code>springfox.documentation.service.RequestParameter#equals</code></p>
<p><code>springfox.documentation.schema.Example#equals</code></p>
<h2 id="2-接口定义"><a href="#2-接口定义" class="headerlink" title="2. 接口定义"></a>2. 接口定义</h2><p>首先，来看看出问题的接口定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(<span class="meta-string">&quot;xxx&quot;</span>)</span></span><br><span class="line"><span class="meta">@ApiResponse(</span></span><br><span class="line"><span class="meta">    code = 0,</span></span><br><span class="line"><span class="meta">    message = <span class="meta-string">&quot;ok&quot;</span>,</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@PostMapping(</span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;/api&quot;</span>,</span></span><br><span class="line"><span class="meta">    consumes = [MediaType.APPLICATION_FORM_URLENCODED_VALUE]</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">api</span><span class="params">(dto:<span class="type">Dto</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dto定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dto</span> </span>&#123;</span><br><span class="line">	<span class="meta">@ApiModelProperty</span></span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> field: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Kotlin编译成Java"><a href="#3-Kotlin编译成Java" class="headerlink" title="3. Kotlin编译成Java"></a>3. Kotlin编译成Java</h2><p>看起来似乎没啥毛病，很nice。为什么会报空指针呢？首先我们来看下Dto编译成Java代码是什么样子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dto</span> </span>&#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span></span><br><span class="line">   <span class="keyword">public</span> String field;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getField() &#123;</span><br><span class="line">      String var1 = <span class="keyword">this</span>.field;</span><br><span class="line">      <span class="keyword">if</span> (var1 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> var1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;field&quot;</span>);</span><br><span class="line">         <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setField(<span class="meta">@NotNull</span> String var1) &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(var1, var1);</span><br><span class="line">      <span class="keyword">this</span>.field = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，field访问修饰符是public。事实上这个public就是罪魁祸首</p>
<h2 id="4-springfox源码分析"><a href="#4-springfox源码分析" class="headerlink" title="4. springfox源码分析"></a>4. springfox源码分析</h2><p>我们先来看一下springfox处理接口参数的一个大致过程</p>
<ol>
<li>判断接口参数前是否加了<code>@RequestBody</code>等参数，如果没加则进入第二步</li>
<li>将Dto里的所有public属性跟public get方法包装成<code>RequestParameter</code></li>
<li>将所有的<code>RequestParameter</code> 添加到<code>HashSet</code></li>
</ol>
<h3 id="1-判断是否加了-RequestBody等参数"><a href="#1-判断是否加了-RequestBody等参数" class="headerlink" title="1. 判断是否加了@RequestBody等参数"></a>1. 判断是否加了<code>@RequestBody</code>等参数</h3><p>先看看第一步相关的源码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> springfox.documentation.spring.web.readers.operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationParameterReader</span> <span class="title">implements</span> <span class="title">OperationBuilderPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;Compatibility&lt;springfox.documentation.service.Parameter, RequestParameter&gt;&gt;</span><br><span class="line">	  readParameters(OperationContext context) &#123;</span><br><span class="line">	    List&lt;ResolvedMethodParameter&gt; methodParameters = context.getParameters();</span><br><span class="line">	    List&lt;Compatibility&lt;springfox.documentation.service.Parameter, RequestParameter&gt;&gt; parameters = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	    int index = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//1. 遍历方法所有参数</span></span><br><span class="line">	    <span class="keyword">for</span> (ResolvedMethodParameter methodParameter : methodParameters) &#123;</span><br><span class="line">			<span class="comment">//2. 判断是否需要扩展。</span></span><br><span class="line">	        <span class="keyword">if</span> (shouldExpand(methodParameter, alternate)) &#123;</span><br><span class="line">	          parameters.addAll(</span><br><span class="line">	              expander.expand(</span><br><span class="line">	                  new ExpansionContext(<span class="string">&quot;&quot;</span>, alternate, context)));</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	          <span class="comment">//...</span></span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> parameters.stream()</span><br><span class="line">	        .filter(hiddenParameter().negate())</span><br><span class="line">	        .collect(toList());</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> boolean shouldExpand(<span class="keyword">final</span> ResolvedMethodParameter parameter, ResolvedType resolvedParamType) &#123;</span><br><span class="line">	    <span class="keyword">return</span> !parameter.hasParameterAnnotation(RequestBody.<span class="keyword">class</span>)</span><br><span class="line">	        &amp;&amp; !parameter.hasParameterAnnotation(RequestPart.<span class="keyword">class</span>)</span><br><span class="line">	        &amp;&amp; !parameter.hasParameterAnnotation(RequestParam.<span class="keyword">class</span>)</span><br><span class="line">	        &amp;&amp; !parameter.hasParameterAnnotation(PathVariable.<span class="keyword">class</span>)</span><br><span class="line">	        &amp;&amp; !builtInScalarType(resolvedParamType.getErasedType()).isPresent()</span><br><span class="line">	        &amp;&amp; !enumTypeDeterminer.isEnum(resolvedParamType.getErasedType())</span><br><span class="line">	        &amp;&amp; !isContainerType(resolvedParamType)</span><br><span class="line">	        &amp;&amp; !isMapType(resolvedParamType);</span><br><span class="line">	  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到shouldExpand会判断我们的参数是否被@RequestBody这类注解标注，而我们定义的接口是一个接收form表单的post接口，其前面的注解应该是<code>@ModelAttribute</code>（不加也可以）。所以这里就会进到<code>expander.expand</code>这里会将类拆解开来，对每个字段逐一解析。 然后进入到如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAttributeParameterExpander</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> List&lt;Compatibility&lt;springfox.documentation.service.Parameter, RequestParameter&gt;&gt; expand(</span><br><span class="line">		      ExpansionContext context) &#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//将model里所有的getter方法跟public修饰的字段包装成ModelAttributeField</span></span><br><span class="line">		    List&lt;ModelAttributeField&gt; attributes =</span><br><span class="line">		        allModelAttributes(</span><br><span class="line">		            propertyLookupByGetter,</span><br><span class="line">		            getters,</span><br><span class="line">		            fieldsByName,</span><br><span class="line">		            alternateTypeProvider,</span><br><span class="line">		            context.ignorableTypes());</span><br><span class="line">				<span class="comment">//处理getter方法跟public字段，将其包装为对应的RequestParamter</span></span><br><span class="line">				simpleFields.forEach(each -&gt; parameters.add(simpleFields(context.getParentName(), context, each)));</span><br><span class="line">				    <span class="keyword">return</span> parameters.stream()</span><br><span class="line">				        .filter(hiddenParameter().negate())</span><br><span class="line">				        .filter(voidParameters().negate())</span><br><span class="line">				        .collect(toList());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;ModelAttributeField&gt; allModelAttributes(</span><br><span class="line">	      Map&lt;Method, PropertyDescriptor&gt; propertyLookupByGetter,</span><br><span class="line">	      Iterable&lt;ResolvedMethod&gt; getters,</span><br><span class="line">	      Map&lt;String, ResolvedField&gt; fieldsByName,</span><br><span class="line">	      AlternateTypeProvider alternateTypeProvider,</span><br><span class="line">	      Collection&lt;Class&gt; ignorables) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//所有getter方法</span></span><br><span class="line">	    Stream&lt;ModelAttributeField&gt; modelAttributesFromGetters =</span><br><span class="line">	        StreamSupport.stream(getters.spliterator(), <span class="literal">false</span>)</span><br><span class="line">	            .filter(method -&gt; !ignored(alternateTypeProvider, method, ignorables))</span><br><span class="line">	            .map(toModelAttributeField(fieldsByName, propertyLookupByGetter, alternateTypeProvider));</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//所有public修饰的字段</span></span><br><span class="line">	    Stream&lt;ModelAttributeField&gt; modelAttributesFromFields =</span><br><span class="line">	        fieldsByName.values().stream()</span><br><span class="line">	            .filter(ResolvedMember::isPublic)</span><br><span class="line">	            .filter(ResolvedMember::isPublic)</span><br><span class="line">	            .map(toModelAttributeField(alternateTypeProvider));</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">return</span> Stream.concat(</span><br><span class="line">	        modelAttributesFromFields,</span><br><span class="line">	        modelAttributesFromGetters)</span><br><span class="line">	        .collect(toList());</span><br><span class="line">	  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来通过<code>ModelAttributeParameterExpander.simpleFields</code>进入如下代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> springfox.documentation.swagger.readers.parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerExpandedParameterBuilder</span> <span class="title">implements</span> <span class="title">ExpandedParameterBuilderPlugin</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> void apply(ParameterExpansionContext context) &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//1. 查找字段上的ApiModelProperty注解，context则为单个字段或者getter方法的信息集合</span></span><br><span class="line">	<span class="comment">//如果字段上存在ApiModelProperty注解，则返回的Optional存在相关注解包装对象</span></span><br><span class="line">	<span class="comment">//如果是getter方法，在context的metadataAccessor中会保留一份getter对应的字段的信息</span></span><br><span class="line">	<span class="comment">//所以这里字段跟getter的处理方式相同</span></span><br><span class="line">    Optional&lt;ApiModelProperty&gt; apiModelPropertyOptional = context.findAnnotation(ApiModelProperty.<span class="keyword">class</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//2. 如果字段上存在ApiModelProperty注解，则执行fromApiModelProperty</span></span><br><span class="line">    apiModelPropertyOptional.ifPresent(apiModelProperty -&gt; fromApiModelProperty(context, apiModelProperty));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，我们的<code>Dto</code>的<code>field</code>字段上是有<code>ApiModelProperty</code>注解的。所以接下来进入<code>fromApiModelProperty</code></p>
<h3 id="2-包装RequestParameter"><a href="#2-包装RequestParameter" class="headerlink" title="2. 包装RequestParameter"></a>2. 包装<code>RequestParameter</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> springfox.documentation.swagger.readers.parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerExpandedParameterBuilder</span> <span class="title">implements</span> <span class="title">ExpandedParameterBuilderPlugin</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> void fromApiModelProperty(</span><br><span class="line">	      ParameterExpansionContext context,</span><br><span class="line">	      ApiModelProperty apiModelProperty) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//1. 生成RequestParameterBuilder</span></span><br><span class="line">	    context.getRequestParameterBuilder()</span><br><span class="line">	           .description(descriptions.resolve(apiModelProperty.value()))</span><br><span class="line">	           .required(apiModelProperty.required())</span><br><span class="line">	           .hidden(apiModelProperty.hidden())</span><br><span class="line">				<span class="comment">//2. apiModelProperty.example()默认返回空字符串。</span></span><br><span class="line">				<span class="comment">//所以这里会生成一个除了value其他字段都为空的Example实例</span></span><br><span class="line">	           .example(new ExampleBuilder().value(apiModelProperty.example()).build())</span><br><span class="line">	           .precedence(SWAGGER_PLUGIN_ORDER)</span><br><span class="line">	           .query(q -&gt; q.enumerationFacet(e -&gt; e.allowedValues(allowable)));</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里就会生成一个跟我们字段或者getter对应的<code>RequestParameterBuilder</code>，且其字段<code>scalarExample</code>除了<code>value</code>以外其他字段都为<code>null</code>。同时可以看出来，字段跟与字段对应的<code>getter</code>生成的<code>RequestParameterBuilder</code>应该是<strong>一模一样的，因为取的都是字段注解上的信息.</strong></p>
<p>所以，其<code>build()</code>出来的<code>RequestParameter</code>的字段值也是一模一样的。因为是<code>RequestParameter#equals</code>报错，我们先来看看其equals方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean equals(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RequestParameter that = (RequestParameter) o;</span><br><span class="line">    <span class="keyword">return</span> parameterIndex == that.parameterIndex &amp;&amp;</span><br><span class="line">        Objects.equals(scalarExample, that.scalarExample);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最终会对<code>RequestParameter</code>里的<code>scalarExample</code>进行equals比较。所以如果<code>scalarExample</code>不为空则必然进入进入<code>Example#equals</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object o) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Example example = (Example) o;</span><br><span class="line">  <span class="keyword">return</span> id.equals(example.id) &amp;&amp;</span><br><span class="line">      Objects.equals(summary, example.summary) &amp;&amp;</span><br><span class="line">      Objects.equals(description, example.description) &amp;&amp;</span><br><span class="line">      value.equals(example.value) &amp;&amp;</span><br><span class="line">      externalValue.equals(example.externalValue) &amp;&amp;</span><br><span class="line">      mediaType.equals(example.mediaType) &amp;&amp;</span><br><span class="line">      extensions.equals(example.extensions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得前面提到的<code>RequestParameterBuilder</code>只为Example的value字段赋了值吗？所以，只要触发<code>Example#equals</code> ，则必然会报出<code>NullPointException</code></p>
<p>所以接下来这个RequestParameterBuilder在哪完成build()其实已经不需要关心了，我们只需要找到是哪里触发了这个equals即可。</p>
<h3 id="3-将RequestParameter-添加到HashSet"><a href="#3-将RequestParameter-添加到HashSet" class="headerlink" title="3. 将RequestParameter 添加到HashSet"></a>3. 将<code>RequestParameter</code> 添加到<code>HashSet</code></h3><p>我们进入第一步所展示的代码的调用方，代码片段如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> springfox.documentation.spring.web.readers.operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationParameterReader</span> <span class="title">implements</span> <span class="title">OperationBuilderPlugin</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> void apply(OperationContext context) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//触发第一步</span></span><br><span class="line">    List&lt;Compatibility&lt;springfox.documentation.service.Parameter, RequestParameter&gt;&gt; compatibilities</span><br><span class="line">        = readParameters(context);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拿出compatibilities#getModern返回的数据组成一个HashSet</span></span><br><span class="line">    Collection&lt;RequestParameter&gt; requestParameters = compatibilities.stream()</span><br><span class="line">        .map(Compatibility::getModern)</span><br><span class="line">        .filter(Optional::isPresent)</span><br><span class="line">        .map(Optional::<span class="keyword">get</span>)</span><br><span class="line">        .collect(toSet());</span><br><span class="line">    context.operationBuilder()</span><br><span class="line">        .requestParameters(aggregator.aggregate(requestParameters));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到HashSet是不是突然想到了什么？没错，HashCode相同导致Hash碰撞进而触发equals。所以我们先来看看<code>compatibilities#getModern</code>究竟返回了什么。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> springfox.documentation.spring.web.plugins;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OperationParameterReader.readParameters</span></span><br><span class="line"><span class="comment">//	-&gt; ModelAttributeParameterExpander.expand</span></span><br><span class="line"><span class="comment">//    -&gt; ModelAttributeParameterExpander.simpleFields</span></span><br><span class="line"><span class="comment">//      -&gt; DocumentationPluginsManager.expandParameter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentationPluginsManager</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> Compatibility&lt;springfox.documentation.service.Parameter, RequestParameter&gt; expandParameter(</span><br><span class="line">		    ParameterExpansionContext context) &#123;</span><br><span class="line">		  <span class="keyword">for</span> (ExpandedParameterBuilderPlugin each : parameterExpanderPlugins.getPluginsFor(context.getDocumentationType())) &#123;</span><br><span class="line">		    each.apply(context);</span><br><span class="line">		  &#125;</span><br><span class="line">		  <span class="keyword">return</span> new Compatibility&lt;&gt;(</span><br><span class="line">		      context.getParameterBuilder().build(),</span><br><span class="line">		      context.getRequestParameterBuilder().build());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在上面列出了调用链，可以看到，<code>compatibilities#getModern</code>返回的就是我们之前说的<code>RequestParameter</code>。好家伙，赶紧去看<code>RequestParameter#hashCode</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> int hashCode() &#123;</span><br><span class="line">  <span class="keyword">return</span> Objects.hash(name,</span><br><span class="line">      parameterIndex,</span><br><span class="line">      <span class="keyword">in</span>,</span><br><span class="line">      description,</span><br><span class="line">      required,</span><br><span class="line">      deprecated,</span><br><span class="line">      hidden,</span><br><span class="line">      parameterSpecification,</span><br><span class="line">      precedence,</span><br><span class="line">      scalarExample,</span><br><span class="line">      examples,</span><br><span class="line">      extensions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出，如果存在两个字段值相同的<code>RequestParameter</code>，则势必会在因为hash碰撞而触发equals，从而最终导致<code>NullPointException</code>。</p>
<h2 id="关于hash碰撞的代码片段"><a href="#关于hash碰撞的代码片段" class="headerlink" title="关于hash碰撞的代码片段"></a>关于hash碰撞的代码片段</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="type">K,V</span>&gt; <span class="title">extends</span> <span class="title">AbstractMap</span>&lt;<span class="type">K,V</span>&gt;</span></span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">	                   boolean evict) &#123;</span><br><span class="line">	        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">			<span class="comment">//为空则初始化</span></span><br><span class="line">	        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">	            n = (tab = resize()).length;</span><br><span class="line">			<span class="comment">//hash值与长度-1按位与。</span></span><br><span class="line">			<span class="comment">//hash值相同的key必然会落到数组中同一个位置从而后来的元素会进入else</span></span><br><span class="line">	        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">	            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">	        <span class="keyword">else</span> &#123;</span><br><span class="line">	            Node&lt;K,V&gt; e; K k;</span><br><span class="line">	            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">	                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">				<span class="comment">//......</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次问题很奇葩，一方面是我对<code>Kotlin</code>还是不够熟，对<code>lateinit</code>的了解仅仅停留在很浅的层次。事实上我觉得这应该是<code>Kotlin</code>的编译不合理之处。因为正常的像<code>var</code>定义的属性，默认编译成java代码后，会生成一个私有的字段跟对应的<code>getter&amp;setter</code>方法。同时，对于<code>lateinit</code>想要实现的功能（如果尝试访问没赋值的属性，会抛出异常），我觉得完全没必要把字段用<code>public</code>来修饰。</p>
<p>另一方面，我觉得<code>springfox</code>的设计也有不合理之处，既然有<code>RequestParameter#equals</code>的存在，为什么要允许前面这种默认只赋值一个<code>Example#value</code>的代码存在呢？且从表现上来看，一个public修饰的字段跟一个对应的getter方法，如果字段上不加@ApiModelProperty，则表现正常，加了，则直接导致NullpointException。这不合理，且容易令人困惑。</p>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p><a href="https://github.com/scientificCommunity/blog-sample/blob/main/src/main/kotlin/org/baichuan/example/spring/springfox/Application.kt">https://github.com/scientificCommunity/blog-sample/blob/main/src/main/kotlin/org/baichuan/example/spring/springfox/Application.kt</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔之Http为什么经常被吐槽慢？</title>
    <url>/posts/bb46fe66/</url>
    <content><![CDATA[<p>http1因为没有对请求跟响应加上唯一标识（历史包袱），为了保证请求跟响应的一一对应，同一个连接上请求的发送必须在上一个请求完成之后（http层面的hol blocking问题）。所以，只要有并发，必然就会有阻塞，这个阻塞会随着请求并发的程度跟网络环境逐渐放大，这也是http1效率低（慢）的主要原因。像1.0的keep-alive出现之前，每次请求都需要重新建立连接，效率更是可怕的低。<br>不过http2在frame（应用层）层面加了一个streamId，使得不同请求的数据可以在同一条连接上混合传输，使得并发的效率得到大幅提升</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>网络通信</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
